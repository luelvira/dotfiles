#+TITLE: My Emacs Configuration
#+AUTHOR: Lucas Elvira Mart√≠n
#+DATE: [2023-12-07 Thu]

* TOC                                                                   :TOC:
- [[#enable-literature-configuration][Enable literature configuration]]
  - [[#lexical-binding][Lexical binding]]
- [[#package-system][Package system]]
- [[#keep-it-clean][Keep it clean]]
- [[#dashboard][Dashboard]]
- [[#general-configuration][General configuration]]
  - [[#set-encding-by-default][Set encding by default]]
  - [[#disable-warnings][Disable warnings]]
  - [[#emacs-as-server][Emacs as server]]
  - [[#autorevert-buffers][Autorevert buffers]]
  - [[#sync-files][Sync files]]
- [[#theming][Theming]]
  - [[#all-the-icons][All the icons]]
  - [[#reduce-distractions][Reduce distractions]]
  - [[#maximize-windows-by-default-and-setup-transparency][Maximize windows by default and setup transparency]]
  - [[#enable-line-numbers][Enable line numbers]]
  - [[#color-theme][Color theme]]
  - [[#fonts][Fonts]]
- [[#keyboard-binding][Keyboard binding]]
  - [[#esc-as-c-g][ESC as C-g]]
  - [[#setup-evil-mode][Setup evil mode]]
  - [[#which-key][Which Key]]
- [[#custom-shortcut-with-general][Custom shortcut with general]]
  - [[#bookmarks-and-buffer][Bookmarks and buffer]]
  - [[#configuration-file][Configuration file]]
  - [[#git][Git]]
  - [[#projectile][Projectile]]
  - [[#org-shortcuts][Org shortcuts]]
  - [[#org-roam-shortcut][Org roam shortcut]]
  - [[#toggle-options][Toggle options]]
  - [[#sync-scripts][Sync scripts]]
  -  [[#end-of-general-parens][End of general parens]]
- [[#editing-configuration][Editing configuration]]
  - [[#default-tab-width][Default tab width]]
- [[#completion-system][Completion system]]
  - [[#ivy-and-counsel][ivy and counsel]]
  - [[#helpul][helpul]]
- [[#file-browser-with-dired][File browser with dired]]
- [[#writting][Writting]]
  - [[#flyspell][Flyspell]]
  - [[#visual-fill-configuration][Visual fill configuration]]
  - [[#text-mode][Text mode]]
- [[#development][Development]]
  - [[#projectile-1][Projectile]]
  - [[#flycheck][Flycheck]]
  - [[#git-1][Git]]
  - [[#vterm][vterm]]
- [[#org-mode][Org mode]]
  - [[#enable-table-of-content][Enable table of content]]
  - [[#define-all-the-variables][Define all the variables]]
  - [[#gtd][GTD]]
  - [[#configure-babel-languages][Configure Babel languages]]
  - [[#bullets][Bullets]]
  - [[#increase-the-size-of-various-heading][Increase the size of various heading]]
  - [[#close-org-mode-configuration][Close org mode configuration]]
  - [[#setting-monospace-fonts-for-required-text][Setting monospace fonts for required text]]
  - [[#custom-function][Custom function]]
  - [[#org-templates][Org templates]]
  - [[#org-auto-tangle][Org-auto-tangle]]
- [[#org-roam][Org roam]]
  - [[#zettelkasten][Zettelkasten]]
  - [[#org-roam-ui][Org-roam-ui]]

* Enable literature configuration
Emacs allows to export src blocks to a ~.el~ file and load them. This is a great option if you would like to describe each part of the configuation and explain a bit of them. To make them, you need to create a ~init.el~ file with the following code

#+begin_example emacs-lisp :tangle init.el
(org-babel-load-file
(expand-file-name
"config.org"
  user-emacs-directory))
 #+end_example

** Lexical binding
Lexical binding is a mode that allows to use special features of the languages. It options tell the configuration that  works as a program more than just a simple configuration

#+begin_src emacs-lisp
;; -*- lexical-binding: t ;-*-
#+end_src

* Package system

I would try to use elpaca as package system.

#+begin_src emacs-lisp
(defvar elpaca-installer-version 0.6)
(defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
(defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
(defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
(defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
                              :ref nil
                              :files (:defaults "elpaca-test.el" (:exclude "extensions"))
                              :build (:not elpaca--activate-package)))
(let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
       (build (expand-file-name "elpaca/" elpaca-builds-directory))
       (order (cdr elpaca-order))
       (default-directory repo))
  (add-to-list 'load-path (if (file-exists-p build) build repo))
  (unless (file-exists-p repo)
    (make-directory repo t)
    (when (< emacs-major-version 28) (require 'subr-x))
    (condition-case-unless-debug err
        (if-let ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
                 ((zerop (call-process "git" nil buffer t "clone"
                                       (plist-get order :repo) repo)))
                 ((zerop (call-process "git" nil buffer t "checkout"
                                       (or (plist-get order :ref) "--"))))
                 (emacs (concat invocation-directory invocation-name))
                 ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
                                       "--eval" "(byte-recompile-directory \".\" 0 'force)")))
                 ((require 'elpaca))
                 ((elpaca-generate-autoloads "elpaca" repo)))
            (progn (message "%s" (buffer-string)) (kill-buffer buffer))
          (error "%s" (with-current-buffer buffer (buffer-string))))
      ((error) (warn "%s" err) (delete-directory repo 'recursive))))
  (unless (require 'elpaca-autoloads nil t)
    (require 'elpaca)
    (elpaca-generate-autoloads "elpaca" repo)
    (load "./elpaca-autoloads")))
(add-hook 'after-init-hook #'elpaca-process-queues)
(elpaca `(,@elpaca-order))
#+end_src

Also, the elapaca repository page tells you to create a ~early-init.el~ file with the following code

#+begin_src emacs-lisp :tangle early-init.el
(setq package-enable-at-startup nil)
#+end_src


*** Elapaca with use-package

#+begin_src emacs-lisp
;; Install a package via the elpaca macro
;; See the "recipes" section of the manual for more details.

;; (elpaca example-package)

;; Install use-package support
(elpaca elpaca-use-package
  ;; Enable :elpaca use-package keyword.
  (elpaca-use-package-mode)
  ;; Assume :elpaca t unless otherwise specified.
  (setq elpaca-use-package-by-default t))

;; Block until current queue processed.
(elpaca-wait)

;;When installing a package which modifies a form used at the top-level
;;(e.g. a package which adds a use-package key word),
;;use `elpaca-wait' to block until that package has been installed/configured.
;;For example:
;;(use-package general :demand t)
;;(elpaca-wait)

;; Expands to: (elpaca evil (use-package evil :demand t))
;; (use-package evil :demand t)

;;Turns off elpaca-use-package-mode current declaration
;;Note this will cause the declaration to be interpreted immediately (not deferred).
;;Useful for configuring built-in emacs features.
;;(use-package emacs :elpaca nil :config (setq ring-bell-function #'ignore))

;; Don't install anything. Defer execution of BODY
;;(elpaca nil (message "deferred"))
#+end_src

*** Allow built-in package updates
#+begin_src emacs-lisp
(setq package-install-upgrade-built-in t)
#+end_src

* Keep it clean

First I define the default emacs back-up where all the cache files will be stored

#+begin_src emacs-lisp
;; Change the user-emacs-directory to keep unwanted things out of ~/.emacs.d
(setq user-emacs-directory (expand-file-name "~/.cache/emacs/")
      url-history-file (expand-file-name "url/history" user-emacs-directory))
;;
;; Use no-littering to automatically set common paths to the new user-emacs-directory

(use-package no-littering)
#+end_src

Then define where will be store the temporal files

#+begin_src emacs-lisp
(setq backup-directory-alist '(("." . "~/.cache/emacs/backup/"))
  backup-by-copying t    ; Don't delink hardlinks
  version-control t      ; Use version numbers on backups
  delete-old-versions t  ; Automatically delete excess backups
  kept-new-versions 20   ; how many of the newest versions to keep
  kept-old-versions 5    ; and how many of the old
  )
#+end_src

* Dashboard
Emacs Dashboard is an extensible startup screen showing you recent files,
bookmarks, agenda items and an Emacs banner.

#+begin_src emacs-lisp
  (use-package dashboard
    :ensure t
    :init      ;; tweak dashboard config before loading it
    (setq initial-buffer-choice 'dashboard-open)
    (setq dashboard-set-heading-icons t)
    (setq dashboard-set-file-icons t)
    (setq dashboard-banner-logo-title "Emacs Is More Than A Text Editor!")
    (setq dashboard-startup-banner 'logo) ;; use standard emacs logo as banner
    (setq dashboard-center-content nil) ;; set to 't' for centered content
    (setq dashboard-items '((recents . 5)
			    (agenda . 5 )
			    (bookmarks . 3)
			    (projects . 5)
			    (registers . 3)))
    :config
    (dashboard-setup-startup-hook)
    :custom
    (dashboard-modify-heading-icons '((recents . "file-text")
				    (bookmarks . "book"))))
#+end_src

* General configuration
** Set encding by default
#+begin_src emacs-lisp
(set-default-coding-systems 'utf-8)
#+end_src

** Disable warnings

#+begin_src emacs-lisp
(setq native-comp-async-report-warnings-errors nil)
#+end_src

** Emacs as server

This command allow to run emacs as server, so all the startup can be done once time and connect client to it each time you need.

#+begin_src emacs-lisp
(server-start)
#+end_src

** Autorevert buffers

#+begin_src emacs-lisp
;; Revert Dired and other buffers
(setq global-auto-revert-non-file-buffers t)

;; Revert buffers when the underlying file has changed
(global-auto-revert-mode 1)
#+end_src

*** Delete current file
Emacs by default does not have a system to delete the current file. But you can use the delete-file function with the buffer-file-name

#+begin_src emacs-lisp
  (defun lem/delete-file ()
    "Delete the current file and kill the buffer"
    (interactive)
    (let ((filename (buffer-file-name)))
      (if filename
          (if (y-or-n-p (concat "Do you really want to delete file " filename "?"))
              (progn (delete-file filename)
                     (message "File delete")
                     (kill-buffer)))
        (message "Not a file visiting buffer!"))))

#+end_src

** Sync files

I have a script which try to keep sync with a repository on codeberg. This repo contains the org files only, and it is named sync.

#+begin_src emacs-lisp
  (defun lem/sync (path)
    (shell-command-to-string (format "/home/lucas/.local/bin/sync.sh %s" path)))

  (defun lem/sync-org ()
    "Sync the Org foler with an external script"
    (interactive)
    (lem/sync "~/Documents/Org"))

  (defun lem/sync-conf ()
    "Sync the config foler with an external script"
    (interactive)
    (lem/sync "~/Documents/git/dotfiles"))
#+end_src

* Theming

** All the icons

This is an icon set that can be used with dashboard, dired, ibuffer and other Emacs programs.

#+begin_src emacs-lisp
(use-package all-the-icons
  :ensure t
  :if (display-graphic-p))

(use-package all-the-icons-dired
  :hook (dired-mode . (lambda () (all-the-icons-dired-mode t))))

  (use-package minions
    :hook (doom-modeline-mode . minions-mode))
#+end_src

** Reduce distractions

#+begin_src emacs-lisp
(setq inhibit-startup-message t)
(scroll-bar-mode -1)        ; Disable visible scrollbar
(tool-bar-mode -1)          ; Disable the toolbar
(tooltip-mode -1)           ; Disable tooltips
(set-fringe-mode 0)        ; Give some breathing room (menu-bar-mode -1)            ; Disable the menu bar
(menu-bar-mode -1)
;; Set up the visible bell
(setq visible-bell t)
(electric-indent-mode -1)
(electric-pair-mode -1)
#+end_src

** Maximize windows by default and setup transparency

#+begin_src emacs-lisp
(set-frame-parameter (selected-frame) 'fullscreen 'maximized)
(add-to-list 'default-frame-alist '(fullscreen . maximized))
;; only for non gnome desktop
(unless (string= (getenv "DESKTOP_SESSION") "gnome")
    (set-frame-parameter nil 'alpha '(100 . 100))
    (add-to-list 'default-frame-alist '(alpha-background . 100)))
#+end_src

** Enable line numbers

#+begin_src emacs-lisp
(column-number-mode)

;; Enable line numbers for some modes
(dolist (mode '(text-mode-hook
                prog-mode-hook
                conf-mode-hook))
  (add-hook mode (lambda () (display-line-numbers-mode 1))))
#+end_src

** Color theme

[[https://github.com/hlissner/emacs-doom-themes][doom-themes]] is a great set of themes with a lot of variety and support for many different Emacs modes.  Taking a look at the [[https://github.com/hlissner/emacs-doom-themes/tree/screenshots][screenshots]] might help you decide which one you like best. You can also run =M-x counsel-load-theme= to choose between them easily.

#+begin_src emacs-lisp
  (use-package doom-themes
    :config
    (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
	  doom-themes-enable-italic t) ; if nil, italics is universally disabled
    (load-theme 'doom-dracula t)
    ;; Enable custom neotree theme (all-the-icons must be installed!)
    (doom-themes-neotree-config)
    ;; Corrects (and improves) org-mode's native fontification.
    (doom-themes-org-config)
    (doom-themes-visual-bell-config))
#+end_src

** Fonts

Defining the various fonts that Emacs will use.

#+begin_src emacs-lisp
  ;; Set the font
  (setq default-mono-font "Fira Code"
	default-variable-pitch-font "Ubuntu")

  (set-face-attribute 'default nil
		      :font default-mono-font
		      :height 110)

  (set-face-attribute 'fixed-pitch nil
		      :family default-mono-font
		      :height 1.0
		      :inherit 'default)

  (set-face-attribute 'variable-pitch nil
		      :family default-variable-pitch-font
		      :inherit 'default)

;; Makes commented text and keywords italics.
;; This is working in emacsclient but not emacs.
;; Your font must have an italic face available.
;(set-face-attribute 'font-lock-comment-face nil
;  :slant 'italic)
;
;(set-face-attribute 'font-lock-keyword-face nil
;  :slant 'italic)
;
;; This sets the default font on all graphical frames created after restarting Emacs.
;; Does the same thing as 'set-face-attribute default' above, but emacsclient fonts
;; are not right unless I also add this method of setting the default font.
;;(add-to-list 'default-frame-alist '(font . "JetBrains Mono-11"))
#+end_src

*** Enable ligatures

Some fonts allow you to use ligatures in some modes. For that, I use the package [[https://github.com/mickeynp/ligature.el][ligature]]

#+begin_src emacs-lisp
  (use-package ligature
  :config
  (ligature-set-ligatures 't '("www"))
  ;; Enable traditional ligature support in eww-mode, if the
  ;; `variable-pitch' face supports it
  (ligature-set-ligatures 'eww-mode '("ff" "fi" "ffi"))
  ;; Enable all Cascadia Code ligatures in programming modes
  (ligature-set-ligatures 'prog-mode '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
                                       ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
                                       "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
                                       "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
                                       "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
                                       "..." "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
                                       "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
                                       "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
                                       ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
                                       "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
                                       "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
                                       "?=" "?." "??" ";;" "/*" "/=" "/>" "//" "__" "~~" "(*" "*)"
                                       "\\\\" "://"))
  ;; Enables ligature checks globally in all buffers. You can also do it
  ;; per mode with `ligature-mode'.
  (global-ligature-mode t))
#+end_src

[[https://github.com/seagle0128/doom-modeline][doom-modeline]] is a very attractive and rich (yet still minimal) mode line
configuration for Emacs.  The default configuration is quite good but you can
check out the [[https://github.com/seagle0128/doom-modeline#customize][configuration options]] for more things you can enable or disable.

*NOTE:* The first time you load your configuration on a new machine, you'll need
to run `M-x all-the-icons-install-fonts` so that mode line icons display
correctly.

#+begin_src emacs-lisp
  (setq display-time-format "%H:%M %b %y"
        display-time-default-load-average nil)
  (display-time-mode 1)
  ;; Dimish modeline clutter hides pesky minor modes
  (use-package diminish)

  (use-package doom-modeline
    :init (doom-modeline-mode 1)
    :custom
    (doom-modeline-height 15)
    (doom-modeline-bar-width 0)
    (doom-modeline-minor-modes t)
    (doom-modeline-persp-name nil)
    (doom-modeline-buffer-file-name-style 'truncate-except-project)
    (doom-modeline-major-mode-icon nil))
#+end_src

* Keyboard binding

** ESC as C-g
#+begin_src emacs-lisp
(global-set-key (kbd "<escape>") 'keyboard-escape-quit)
;; By default, Emacs requires you to hit ESC trhee times to escape quit the minibuffer
(global-set-key [escape] 'keyboard-escape-quit)
#+end_src

** Setup evil mode
Evil mode is a mayor mode that allow to use vim keybindings in emacs

*** Set the undo system
#+begin_src emacs-lisp
(use-package undo-tree
  :init
  (global-undo-tree-mode 1)
:config
(setq undo-tree-auto-save-history nil))
#+end_src

*** Set the major mode
This configuration uses [[https://evil.readthedocs.io/en/latest/index.html][evil-mode]] for a Vi-like modal editing
experience. [[https://github.com/noctuid/general.el][general.el]] is used for easy keybinding configuration that integrates
well with which-key. [[https://github.com/emacs-evil/evil-collection][evil-collection]] is used to automatically configure various
Emacs modes with Vi-like keybindings for evil-mode.

#+begin_src emacs-lisp

  ;; disable the arrows in insert mode
  (defun rune/dont-arrow-me-bro ()
    (interactive)
    (message "Arrow keys are bad, you know?"))


  (use-package evil
    :init
    (setq evil-want-integration t
	  evil-want-keybinding nil
	  evil-want-C-u-scroll t
	  evil-want-C-i-jump t
	  evil-undo-system 'undo-tree
	  evil-respect-visual-line-mode t)
    :config
    (evil-mode 1)
    (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state)
    (define-key evil-insert-state-map (kbd "C-h") 'evil-delete-backward-char-and-join)
    (evil-set-initial-state 'messages-buffer-mode 'normal)
    (evil-set-initial-state 'dashboard-mode 'normal)
       ;;; Disable arrow keys in insert mode
    (define-key evil-insert-state-map (kbd "<left>") 'rune/dont-arrow-me-bro)
    (define-key evil-insert-state-map (kbd "<right>") 'rune/dont-arrow-me-bro)
    (define-key evil-insert-state-map (kbd "<down>") 'rune/dont-arrow-me-bro)
    (define-key evil-insert-state-map (kbd "<up>") 'rune/dont-arrow-me-bro))
 #+end_src

*** Install evil-collection
Evil collection is a package that provide evil keybindings for a lot of modes

#+begin_src emacs-lisp
  (use-package evil-collection
    :after evil
    :custom
    (evil-collection-outline-bind-tab-p nil)
    :config
    (evil-collection-init))


  (use-package evil-numbers
    :after evil
    :hook 'lem/evil-mode-number-hook
    :config
  (define-key evil-normal-state-map (kbd "C-a +") 'evil-numbers/inc-at-pt)
  (define-key evil-normal-state-map (kbd "C-a -") 'evil-numbers/dec-at-pt)
  (define-key evil-normal-state-map (kbd "C-a g +") 'evil-numbers/inc-at-pt-incremental)
  (define-key  evil-normal-state-map (kbd "C-a g -") 'evil-numbers/dec-at-pt-incremental))

  (use-package evil-surround
    :ensure t
    :config
    (global-evil-surround-mode 1))
#+end_src

** Which Key

[[https://github.com/justbur/emacs-which-key][which-key]] is a useful UI panel that appears when you start pressing any key binding in Emacs to offer you all possible completions for the prefix.  For example, if you press =C-c= (hold control and press the letter =c=), a panel will appear at the bottom of the frame displaying all of the bindings under that prefix and which command they run. This is very useful for learning the possible key bindings in the mode of your current buffer.

#+begin_src emacs-lisp
  (use-package which-key
    :init (which-key-mode)
    :diminish which-key-mode
    :config
    (setq which-key-idle-delay 0.3
	  which-key-side-window-location 'bottom
	  which-key-sort-order #'which-key-key-order-alpha
	  which-key-allow-imprecise-window-fit nil
	  which-key-sort-uppercase-first nil
	  which-key-add-column-padding 1
	  which-key-max-display-columns nil
	  which-key-min-display-lines 6
	  which-key-side-window-slot -10
	  which-key-side-window-max-height 0.25
	  which-key-max-description-length 25
	  which-key-allow-imprecise-window-fit nil
	  which-key-separator " ‚Üí " ))
#+end_src

* Custom shortcut with general

#+begin_src emacs-lisp
  (use-package general
    :config
    (general-evil-setup t)
    (general-create-definer lem/leader-key-def
      :keymaps '(normal insert visual emacs)
      :prefix "SPC"
      :global-prefix "C-SPC")
;; The general use-package is note close
#+end_src

** Bookmarks and buffer
Use 'SPC b' for keybinings related to bookmarks and buffers

| COMMAND         | DESCRIPTION                              | KEYBINDING |
|-----------------+------------------------------------------+------------|
| list-bookmarks  | /List bookmarks/                         | SPC b L    |
| bookmark-set    | /Set bookmark/                           | SPC b m    |
| bookmark-delete | /Delete bookmark/                        | SPC b M    |
| bookmark-save   | /Save current bookmark to bookmark file/ | SPC b w    |

#+begin_src emacs-lisp
  (setq bookmark-default-file (expand-file-name "bookmarks" user-emacs-directory))
  (lem/leader-key-def
    "b" '(:ignore t :which-key "buffers/bookmarks")
    "bl" '(list-bookmarks :which-key "List bookmarks")
    "bm" '(bookmark-set :which-key "Set bookmark")
    "bd" '(bookmark-delete :which-key "Delete bookmark")
    "bw" '(bookmark-save :which-key "Save current bookmark to bookmark file"))

#+end_src

*** Buffers
Regarding /buffers/, the text you are editing in Emacs resides in an object
called a /buffer/. Each time you visit a file, a buffer is used to hold the
file‚Äôs text. Each time you invoke Dired, a buffer is used to hold the directory
listing.  /Ibuffer/ is a program that lists all of your Emacs /buffers/,
allowing you to navigate between them and filter them.

| COMMAND               | DESCRIPTION            | KEYBINDING |
|-----------------------+------------------------+------------|
| counsel-switch-buffer | /change Buffer/        | SPC b i    |
| kill-buffer           | /Kill current buffer/  | SPC b k    |
| next-buffer           | /Goto next buffer/     | SPC b n    |
| previous-buffer       | /Goto previous buffer/ | SPC b p    |
| save-buffer           | /Save current buffer/  | SPC b s    |


#+begin_src emacs-lisp
  (lem/leader-key-def
    "bi" '(counsel-switch-buffer :which-key "Counsel switch buffer")
    "bk" '(kill-current-buffer :whick-key "Kill current buffer")
    "bn" '(next-buffer :whick-key "Goto next buffer")
    "bp" '(previous-buffer :whick-key "Goto previous-buffer buffer")
    "bs" '(save-buffer :whick-key "Save current buffer"))
#+end_src

*** Dired keys

#+begin_src emacs-lisp
  (lem/leader-key-def
    "d" '(:ignore t :wk "Dired")
    "d d" '(dired :wk "Open dired")
    "d j" '(dired-jump :wk "Dired jump to current")
    "d n" '(neotree-dir :wk "Open directory in neotree")
    "d p" '(peep-dired :wk "Peep-dired"))
#+end_src

*** Eval expressions

| Command         | Description | shortcut |
|-----------------+-------------+----------|
| eval-buffer     |             | "eb"     |
| eval-defun      |             | "ed"     |
| eval-expression |             | "ee"     |
| eval-last-sexp  |             | "el"     |
| eval-region     |             | "er"     |

#+begin_src emacs-lisp
  (lem/leader-key-def
    "e" '(:ignore t :wk "Eshell/Evaluate")    
    "eb" '(eval-buffer :wk "Evaluate elisp in buffer")
    "ed" '(eval-defun :wk "Evaluate defun containing or after point")
    "ee" '(eval-expression :wk "Evaluate and elisp expression")
    "el" '(eval-last-sexp :wk "Evaluate elisp expression before point")
    "er" '(eval-region :wk "Evaluate elisp in region"))

#+end_src

*** Files operations

| Command           | Description          | shortcut |
|-------------------+----------------------+----------|
| counsel-recentf   | Display recent files | r        |
| lem/delete-file   | Delete current file  | D        |
| counsel-find-file | Find files in CW     | f        |

#+begin_src emacs-lisp
  (lem/leader-key-def
    "f" '(:ignore t :which-key  "Files")
    "fd" '(find-grep-dired :whick-key "Search for string in files in DIR")
    "fr" '(counsel-recentf :which-key "Recent files")
    "fD" '(lem/delete-file :which-key "Delete current file")
    "ff" '(counsel-find-file :which-key "Find files"))
#+end_src

** Configuration file
We can set a sortcut to open the config file from the emacs directory

#+begin_src emacs-lisp
  (lem/leader-key-def
   "fp" '((lambda () (interactive) (counsel-find-file "~/Documents/git/dotfiles")) :which-key "Config")
   "fc" '((lambda () (interactive) (find-file "~/Documents/git/dotfiles/.emacs.d/config.org")) :which-key "Emacs Config file"))
#+end_src

** Git

| COMMAND                  | DESCRIPTION          | KEYBINDING |
|--------------------------+----------------------+------------|
| magit-status             | launch magit         | gs         |
| magit-diff-unstaged      | git diff             | gd         |
| magit-branch-or-checkout | git checkout         | gc         |
| magit-log-current        | git log              | glc        |
| magit-log-buffer-file    | git log current file | glf        |
| magit-branch             | git branch           | gb         |
| magit-push-current       | git push             | gP         |
| magit-pull-branch        | git pull             | gp         |
| magit-fetch              | git fetch            | gf         |
| magit-fetch-all          | git fetch --all      | gF         |
| magit-rebase             | git rebase           | gr         |

#+begin_src emacs-lisp
(lem/leader-key-def
  "g"   '(:ignore t :which-key "git")
  "gs"  'magit-status
  "gd"  'magit-diff-unstaged
  "gc"  'magit-branch-or-checkout
  "gl"   '(:ignore t :which-key "log")
  "glc" 'magit-log-current
  "glf" 'magit-log-buffer-file
  "gb"  'magit-branch
  "gP"  'magit-push-current
  "gp"  'magit-pull-branch
  "gf"  'magit-fetch
  "gF"  'magit-fetch-all
  "gr"  'magit-rebase)
#+end_src
** Projectile

#+begin_src emacs-lisp
    (lem/leader-key-def
      "p"  '(:ignore t :which-key "Projectile")
      "pf" '(projectile-find-file :which-key "Projectile find file")
      "ps" '(projectile-switch-project :which-key "Projectile switch project")
      "pF" '(counsel-projectile-rg :which-key "Rip grep")
      "pc" '(projectile-compile-project :which-key "Compile Project")
      "pd" '(projectile-dired :which-key "Projectile dired")
      "pp" '(counsel-projetile :which-key "Counsel projectile"))
#+end_src

** Org shortcuts
#+begin_src emacs-lisp
 (lem/leader-key-def
    "o" '(:ignore t :which-key "org mode")
    "oi" '(:ignore t :which-key "Insert")
    "oil" '(org-insert-link :which-key "insert link")
    "on"  '(org-toggle-narrow-to-subtree :which-key "toggle narrow")
    "os"  '(lem/org-search :which-key "search notes")
    "oa" '(org-agenda :which-key "Status")
    ;;"ot" '(org-todo-list :which-key "Show TODOs")
    "oc" '(org-capture t :which-key "Capture")
    "op" '(:ignore t :which-key "Pomodoro")
    "ops" '(org-pomodoro :whick-key "Start org pomodoro")
    "opt" '(set-pomodoro-timer :which-key "Set pomodoro timer")) 
#+end_src
** Org roam shortcut
#+begin_src emacs-lisp
  (lem/leader-key-def
    "or"  '(:ignore t :which-key "Org roam")
    "orl" '(org-roam-buffer-togle :which-key "Org roam buffer togle")
    "orf" '(org-roam-node-find :whick-key "Org roam node find")
    "ori" '(org-roam-node-insert :whick-key "Org roam node insert")
    "orI" '(org-roam-node-insert-immediate :which-key "Org roam insert immediately")
    "orc" 'my/org-roam-capture-task)
#+end_src
** Toggle options
#+begin_src emacs-lisp
  (lem/leader-key-def
    "t"  '(:ignore t :which-key "toggles")
    "tw" '(whitespace-mode :which-key "whitespace")
    "td" '(lem/switch-dictionary :which-key "Toggle between dictionaries"))
#+end_src

** Sync scripts

#+begin_src emacs-lisp
  (lem/leader-key-def
  "s" '(:ignore t :which-key "sync")
  "so" '(lem/sync-org :which-key "Sync org files")
  "sc" '(lem/sync-conf :which-key "Sync config folder"))
#+end_src

**  End of general parens
#+begin_src emacs-lisp
;; end of general parents
)
#+end_src

* Editing configuration


** Default tab width

Default tab width is 8, which is too much. We can change it to 4.

#+begin_src emacs-lisp
(setq-default tab-width 2)
(setq-default evil-shift-width tab-width)
;; use spaces instead of tabs
(setq-default indent-tabs-mode nil)
#+end_src

* Completion system
[[https://company-mode.github.io/][Company]] is a text completion framework for Emacs. The name stands for ‚Äúcomplete anything‚Äù.  Completion will start automatically after you type a few letters. Use M-n and M-p to select, <return> to complete or <tab> to complete the common part.

#+begin_src emacs-lisp
(use-package company
  :defer 2
  :diminish
  :custom
  (company-begin-commands '(self-insert-command))
  (company-idle-delay .1)
  (company-minimum-prefix-length 2)
  (company-show-numbers t)
  (company-tooltip-align-annotations 't)
  (global-company-mode t))

(use-package company-box
  :after company
  :diminish
  :hook (company-mode . company-box-mode))
  
#+end_src

** ivy and counsel

ivy is a generic completion mechanism for Emacs. It is based on the idea of incremental narrowing: the list of candidates is filtered as you type more characters. It is similar to ido-mode, but is more powerful and flexible.

[[https://oremacs.com/swiper/][Ivy]] is an excellent completion framework for Emacs.  It provides a minimal yet powerful selection menu that appears when you open files, switch buffers, and for many other tasks in Emacs.  Counsel is a customized set of commands to replace `find-file` with `counsel-find-file`, etc which provide useful commands for each of the default completion commands.

[[https://github.com/Yevgnen/ivy-rich][ivy-rich]] adds extra columns to a few of the Counsel commands to provide more information about each item.

#+begin_src emacs-lisp
  (use-package hydra
    :defer 1)

  (use-package ivy
    :diminish
    :bind (("C-s" . swiper)
           :map ivy-minibuffer-map
           ("TAB" . ivy-alt-done)
           ("C-l" . ivy-alt-done)
           ("C-j" . ivy-next-line)
           ("C-k" . ivy-previous-line)
           :map ivy-switch-buffer-map
           ("C-k" . ivy-previous-line)
           ("C-l" . ivy-done)
           ("C-d" . ivy-switch-buffer-kill)
           :map ivy-reverse-i-search-map
           ("C-k" . ivy-previous-line)
           ("C-d" . ivy-reverse-i-search-kill))
    :init
    (ivy-mode 1)
    :config
    (setq ivy-use-virtual-buffers t)
    (setq ivy-wrap t)
    (setq ivy-count-format "(%d/%d) ")
    (setq enable-recursive-minibuffers t)
    (setf (alist-get 'counsel-projectile-ag ivy-height-alist) 15)
    (setf (alist-get 'counsel-projectile-rg ivy-height-alist) 15)
    (setf (alist-get 'swiper ivy-height-alist) 15)
    (setf (alist-get 'counsel-switch-buffer ivy-height-alist) 7))

  ;(lem/leader-key-def
  ;  "C-S" '(counsel-projectile-grep :which-key "Projectile grep"))


  (use-package ivy-hydra
    :defer t
    :after hydra)

  (use-package ivy-rich
    :init
    (ivy-rich-mode 1)
    :after counsel
    :config
    (setq ivy-format-function #'ivy-format-function-line)
    (setq ivy-rich-display-transformers-list
          (plist-put ivy-rich-display-transformers-list
                     'ivy-switch-buffer
                     '(:columns
                       ((ivy-rich-candidate (:width 40))
                        (ivy-rich-switch-buffer-indicators (:width 4 :face error :align right)); return the buffer indicators
                        (ivy-rich-switch-buffer-major-mode (:width 12 :face warning))          ; return the major mode info
                        (ivy-rich-switch-buffer-project (:width 15 :face success))             ; return project name using `projectile'
                        (ivy-rich-switch-buffer-path (:width (lambda (x) (ivy-rich-switch-buffer-shorten-path x (ivy-rich-minibuffer-width 0.3))))))  ; return file path relative to project root or `default-directory' if project is nil
                       :predicate
                       (lambda (cand)
                         (if-let ((buffer (get-buffer cand)))
                             ;; Don't mess with EXWM buffers
                             (with-current-buffer buffer
                               (not (derived-mode-p 'exwm-mode)))))))))
#+end_src

*** Counsel
Counsel need to be installed before ivy. Also, Counsel provides ivy and swipper as dependencies, but I will install ivy manually

#+begin_src emacs-lisp

  (use-package counsel
    :demand t
    :bind (("M-x" . counsel-M-x)
           ("C-x b" . counsel-switch-buffer)
           ("C-x C-f" . counsel-find-file)
           ;; ("C-M-j" . counsel-switch-buffer)
           ("C-M-l" . counsel-imenu)
           :map minibuffer-local-map
           ("C-r" . 'counsel-minibuffer-history))
    :custom
    (counsel-linux-app-format-function #'counsel-linux-app-format-function-name-only)
    :config
    (setq ivy-initial-inputs-alist nil)) ;; Don't start searches with ^
#+end_src

*** Disable '^' of M-x

The following line removes the annoying ‚Äò^‚Äô in things like counsel-M-x and other ivy/counsel prompts.  The default ‚Äò^‚Äô string means that if you type something immediately after this string only completion candidates that begin with what you typed are shown.  Most of the time, I‚Äôm searching for a command without knowing what it begins with though.

#+begin_src emacs-lisp
(setq ivy-initial-inputs-alist nil)
#+end_src

*** Install Smex

Smex is a package that makes M-x remember out history

#+begin_src emacs-lisp
(use-package smex
:config
(smex-initialize))
#+end_src

*** Orderless

Orderless improves candidate filtering create pattern by words separate with spaces and display any command which has the same words in any order

#+begin_src emacs-lisp
(use-package orderless
  :ensure t
  :custom
  (completion-styles '(orderless basic))
  (completion-category-overrides '((file (styles basic partial-completion)))))
#+end_src


** helpul

[[https://github.com/Wilfred/helpful][Helpful]] adds a lot of very helpful (get it?) information to Emacs' =describe-= command buffers.  For example, if you use =describe-function=, you will not only get the documentation about the function, you will also see the source code of the function and where it gets used in other places in the Emacs configuration.  It is very useful for figuring out how things work in Emacs.


#+begin_src emacs-lisp
(use-package helpful
  :custom
  (counsel-describe-function-function #'helpful-callable)
  (counsel-describe-variable-function #'helpful-variable)
  :bind
  ([remap describe-function] . counsel-describe-function)
  ([remap describe-command] . helpful-command)
  ([remap describe-variable] . counsel-describe-variable)
  ([remap describe-key] . helpful-key))
#+end_src

* File browser with dired

#+begin_src emacs-lisp :tangle no
  (use-package dired
      :ensure nil
      :elpaca nil
      :defer 1
      :config
      (setq dired-listing-swithces "--group-directories-first"
            dired-omit-files "^\\.[^.].*"
            delete-by-moving-to-trash t)
      (autoload 'dired-omit-mode "dired-x")
      (add-hook 'dired-load-hook
                (lambda ()
                  (interactive)
                  (dired-collapse)))
      (add-hook 'dired-mode-hook
                (lambda () (interactive)
                  (dired-omit-mode 1)
                  (dired-hide-details-mode 1)
                  (all-the-icons-dired-mode 1)
                  (hl-line-mode 1))))

    (use-package dired-single
      :defer t)

    (use-package dired-ranger
      :defer t)

    (use-package dired-collapse
      :defer t)

    (evil-collection-define-key 'normal 'dired-mode-map
      "h" 'dired-single-up-directory
      "H" 'dired-omit-mode
      "l" 'dired-single-buffer
      "y" 'dired-ranger-copy
      "X" 'dired-ranger-move
      "p" 'dired-ranger-paste)
#+end_src

#+begin_src emacs-lisp
(use-package dired-open
  :config
  (setq dired-open-extensions '(("gif" . "sxiv")
                                ("jpg" . "sxiv")
                                ("png" . "sxiv")
                                ("mkv" . "mpv")
                                ("mp4" . "mpv"))))

(use-package peep-dired
  :after dired
  :hook (evil-normalize-keymaps . peep-dired-hook)
  :config
    (evil-define-key 'normal dired-mode-map (kbd "h") 'dired-up-directory)
    (evil-define-key 'normal dired-mode-map (kbd "l") 'dired-open-file) ; use dired-find-file instead if not using dired-open package
    (evil-define-key 'normal peep-dired-mode-map (kbd "j") 'peep-dired-next-file)
    (evil-define-key 'normal peep-dired-mode-map (kbd "k") 'peep-dired-prev-file)
)
#+end_src

* Writting
** Flyspell
Fly spell is a mode that allows you to see typing errors. By default it is disable, but can be configure to be used on different kinds of situations.

#+begin_src emacs-lisp :tangle no
  (use-package flyspell
      :config
      (setq ispell-program-name "hunspell"
	    ispell-default-dictionary "en_US")
      :hook (text-mode . flyspell-mode)
      :bind (("M-<f7>" . flyspell-buffer)
	     ("<f7>" . flyspell-word)
	     ("C-;" . flyspell-auto-correct-previous-word)))

#+end_src

We can configure multiples dictionaries and toggle between them

#+begin_src emacs-lisp
  (defun lem/switch-dictionary()
    (interactive)
    (let* ((dic ispell-current-dictionary)
	   (change (if (string= dic "en_US") "es_ES" "en_US")))
      (ispell-change-dictionary change)
      (message "Dictionary switched from %s to %s" dic change)
      ))
#+end_src

*** Language tool

Language tool is a software that check both, grammar and spelling in different languages.

#+begin_src bash
curl https://languagetool.org/download/LanguageTool-stable.zip -o /tmp/LanguageTool-stable.zip
mkdir -p ~/.local/lib/
unzip /tmp/LanguageTool-stable.zip -d ~/.local/lib/languageTool
#+end_src

#+begin_src emacs-lisp :tangle no
  (use-package langtool
     :config
     (setq langtool-language-tool-jar "~/.local/lib/languageTool/LanguageTool-6.3/languagetool-commandline.jar"
  langtool-default-language "en-US"))
#+end_src

** Visual fill configuration

#+begin_src emacs-lisp 
;; Wrap the text in a custom column size
(defun lem/org-mode-visual-fill ()
  (setq visual-fill-column-width 100
        fill-column 80
        visual-fill-column-center-text nil))

(use-package visual-fill-column
  :defer t
  :hook (text-mode . lem/org-mode-visual-fill))
#+end_src

** Text mode

Aditionaly to the last hook I will make more adjustement into the text view.

#+begin_src emacs-lisp
  (defun lem/text-mode-setup ()
    (setq fill-column 80)
    (variable-pitch-mode 1)
    (auto-fill-mode 1)
    (visual-fill-column-mode 0)
    (visual-line-mode)
    (setq evil-auto-indent nil))

  (add-hook 'text-mode-hook 'lem/text-mode-setup)
#+end_src

* Development

** Projectile

#+begin_src emacs-lisp
(use-package projectile
  :config
  (projectile-mode 1))

   (use-package counsel-projectile
      :after projectile
      :bind (("C-M-p" . counsel-projectile-find-file))
      :config
      (counsel-projectile-mode))
#+end_src

** Flycheck

Install =luacheck= from your Linux distro's repositories for flycheck to work correctly with lua files.  Install =python-pylint= for flycheck to work with python files.  Haskell works with flycheck as long as =haskell-ghc= or =haskell-stack-ghc= is installed.  For more information on language support for flycheck, [[https://www.flycheck.org/en/latest/languages.html][read this]].

#+begin_src emacs-lisp
(use-package flycheck
  :ensure t
  :defer t
  :diminish
  :init (global-flycheck-mode))
#+end_src

** Git
*** Magit

#+begin_src emacs-lisp
(use-package seq)
  (use-package magit)
#+end_src

*** Git gutter
Git gutter is a software which make easy to view the difference between a file and the last commit from the same file

#+begin_src emacs-lisp
    (use-package git-gutter
      :ensure t
      :diminish
      :hook ((prog-mode . git-gutter-mode)
             (text-mode . git-gutter-mode))
      :config
      (setq git-gutter:update-interval 0.2))

    (use-package git-gutter-fringe
      :ensure t
      :config
      (define-fringe-bitmap 'git-gutter-fr:added [224] nil nil '(center repeated))
      (define-fringe-bitmap 'git-gutter-fr:modified [224] nil nil '(center repeated))
      (define-fringe-bitmap 'git-gutter-fr:deleted [128 192 224 240] nil nil 'bottom))
#+end_src

*** Ediff

~ediff~ is a diff program that is built into Emacs.  By default, ‚Äòediff‚Äô splits
files vertically and places the ‚Äòhelp‚Äô frame in its own window.  I have changed
this so the two files are split horizontally and the ~help~ frame appears as a
lower split within the existing window.  Also, I create my own ‚Äòdt-ediff-hook‚Äô
where I add ~j/k~ for moving to next/prev diffs.  By default, this is set to
~n/p~.
#+begin_src emacs-lisp
(setq ediff-split-window-function 'split-window-horizontally
      ediff-window-setup-function 'ediff-setup-windows-plain)

(defun dt-ediff-hook ()
  (ediff-setup-keymap)
  (define-key ediff-mode-map "j" 'ediff-next-difference)
  (define-key ediff-mode-map "k" 'ediff-previous-difference))

(add-hook 'ediff-mode-hook 'dt-ediff-hook)
#+end_src

** vterm
vterm enables the use of fully-fledged terminal applications within Emacs so
that I don't need an external terminal emulator.

It need to be compiled, so you need to install first some dependencies

#+begin_src shell
  apt install make cmake libterm-bin libterm
#+end_src

#+begin_src emacs-lisp
  (use-package vterm
    :commands vterm
    :config
    (setq vterm-max-scrollback 10000))

  (add-to-list 'display-buffer-alist
               '("\*vterm\*"
                 (display-buffer-in-side-window)
                 (window-height . 0.25)
                 (side . bottom)
                 (slot . 0)))
  ;;Still does not work
  (add-hook 'vterm-mode-hook 'evil-emacs-state)
  (add-hook 'term-mode-hook 'evil-emacs-state)

#+end_src

* Org mode

** Enable table of content

#+begin_src emacs-lisp
(use-package toc-org
    :commands toc-org-enable
    :init (add-hook 'org-mode-hook 'toc-org-enable))
#+end_src

** Define all the variables 

#+begin_src emacs-lisp
 (defun lem/org-mode-hook ()
    (org-indent-mode)
      (diminish org-indent-mode))

  (use-package org
  :hook (org-mode . lem/org-mode-hook)
  :elpaca nil
  :config
  (setq org-directory "~/Documents/Org/"
        org-default-notes-file (concat org-directory "Inbox.org")
        org-ellipsis " ‚ñæ"
        ;org-superstar-headline-bullets-list '("‚óâ" "‚óè" "‚óã" "‚óÜ" "‚óè" "‚óã" "‚óÜ")
        ;org-superstar-item-bullet-alist '((?- . ?‚û§) (?+ . ?‚ú¶)) ; changes +/- symbols in item lists
        org-log-done 'time
        org-hide-emphasis-markers nil
        org-table-convert-region-max-lines 20000
        org-src-fontify-natively t
        org-fontify-quote-and-verse-blocks t
        org-src-tab-acts-natively t
        org-edit-src-content-indentation 2
        org-hide-block-startup nil
        org-src-preserve-indentation nil
        org-cycle-separator-lines 2
        org-refile-targets '((nil :maxlevel . 2)
                            (org-agenda-files :maxlevel . 1))
          org-outline-path-complete-in-steps nil
          org-refile-use-outline-path t)
#+end_src

The org mode is not close

** GTD
*** Multiple  keyword sets in one file
From the [[https://orgmode.org/manual/Multiple-sets-in-one-file.html][org manual]], sometimes you want to use different sets of TODO keywords in parallel. For
example a set for task that could be =DONE= or =TODO=, other task that could depends on other and
include the keyword =WAITING= and so on.

IMPORTANT* You can only use set at time, so you need first to select the correct workflow. The
shortcut to select them is: =C-u C-u C-c C-t=;  =C-s-RIGHT=;  =C-s-LEFT=

***  Workflow states
- *TODO*: A task which should be done, but is not processed
- *NEXT*: With the GTD flow, the next task to be done
- *WAIT*: This task depends on other person, so it's not actionable
- *DONE*: Need explication?

#+begin_src emacs-lisp
  (setq org-todo-keywords
        '((sequence "TODO(t)" "IN PROGRESS(p)"  "NEXT(n)" "WAIT(w)" "|" "DONE(d!)" "CANCELED(c!)")))
#+end_src
*** Tags

Tags helps to filter over all task. This task are mutually exclusive, allowing to determinate its context.
- *batch* Low effort
- *followup* Someone is waiting on me to finish this task
#+begin_src emacs-lisp
  (setq org-tag-alist
      '((:startgroup . nil)
       ;Put mutually exclusive tags here
       ("@home" . ?H )
       ("@PHD" . ?P)
       ("@UI" . ?U)
       (:endgroup . nil)))
#+end_src

*** Agendas
Configure the agenda views

#+begin_src emacs-lisp
  (setq org-agenda-files
        (mapcar (lambda (file) (concat org-directory file)) '("Tasks.org" "Habits.org"))
        org-agenda-window-setup 'current-window
        org-agenda-span 'week
        org-agenda-start-with-log-mode t
        org-log-into-drawer t
        org-columns-default-format "%20CATEGORY(Category) %30ITEM(Task) %4TODO %6Effort(Estim){:} %20SCHEDULED %20DEADLINE %6CLOCKSUM(Clock) %TAGS")
#+end_src

Org agenda is a mode of emacs that allows you to view the task for the week

Note 1* You can shcedule the todos with org-shedule command or due time with
org-deadline. To move around the date use ~Shift+arrows~


Note 2*: We can get a repeat item ading to the deadline the period of time to
be repeat, for example a birthday that is repeat each year (see the agenda file)

*** Control time per task

Emacs give you a way to capture the time you spends on each task. You only need
go over the task and execute the command =org-clock-in= and when you stop or
finish go again over the task and run =org-clock-out=

#+begin_src emacs-lisp
  (setq org-clock-persist 'history)
  (org-clock-persistence-insinuate)
#+end_src

*** Capture template for task

  The following templates should be used to customize the behavior of the capture process for new tasks.

#+begin_src emacs-lisp
  (setq org-capture-templates
        `(("t" "Task" entry (file+headline ,(concat org-directory "Tasks.org") "Inbox")
          "* TODO %?\nAdded at: %U" :empty-lines 1)))
#+end_src

*** Pomodoro
#+begin_src emacs-lisp :tangle no
(use-package org-pomodoro
    :after org
    :config
    (setq
     alert-user-configuration (quote ((((:category . "org-pomodoro")) libnotify nil)))
     org-pomodoro-length 90
     org-pomodoro-short-break-length 10
     org-pomodoro-long-break-length 20
     org-pomodoro-clock-break t
     org-pomodoro-manual-break t))

  (defun set-pomodoro-timer (minutes)
    (interactive "nMinutes: ")
    (setq org-pomodoro-length minutes))

#+end_src

*** Habit

#+begin_src emacs-lisp
  (require 'org-habit)
  (add-to-list 'org-modules 'org-habit)
  (setq org-habit-graph-column 60
        org-habit-show-all-today nil
        org-habit-show-habits-only-for-today nil)
#+end_src
** Configure Babel languages

To execute or export code in org-mode code blocks, you‚Äôll need to set up org-babel-load-languages
for each language you‚Äôd like to use. [[https:orgmode.org/worg/org-contrib/babel/languages/index.html][This page]] documents all of the languages that you can use with
org-babel.

#+begin_src emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (python . t)
   (js . t)
   (shell . t)
   (gnuplot . t)))

(push '("conf-unix" . conf-unix) org-src-lang-modes)
(org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages)
#+end_src

*** Structure templates
Org Mode's [[https://orgmode.org/manual/Structure-Templates.html][structure templates]] feature enables you to quickly insert code blocks into your Org files
in combination with =org-tempo= by typing =<= followed by the template name like =el= or =py= and
then press =TAB=.  For example, to insert an empty =emacs-lisp= block below, you can type =<el= and
press =TAB= to expand into such a block.

You can add more =src= block templates below by copying one of the lines and
changing the two strings at the end, the first to be the template name and the
second to contain the name of the language [[https://orgmode.org/worg/org-contrib/babel/languages.html][as it is known by Org Babel]].
#+begin_src emacs-lisp
  ;; This is needed as of Org 9.2
  (require 'org-tempo)

  (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
  (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("py" . "src python"))
  (add-to-list 'org-structure-template-alist '("js" . "src python"))
  (add-to-list 'org-structure-template-alist '("ex" . "export"))
#+end_src

** Bullets
Use bullet characters instead of asterisks, plus set the header font sizes to
something more palatable. A fair amount of inspiration has been taken from [[https://zzamboni.org/post/beautifying-org-mode-in-emacs/][this
blog post]].
#+begin_src emacs-lisp :tangle no
  (use-package org-superstar
    :after org
    :hook (org-mode . org-superstar-mode)
    :custom
    (org-superstar-remove-leading-stars t)
    (org-superstar-headline-bullets-list '("‚óâ" "‚óã" "‚óè" "‚óã" "‚óè" "‚óã" "‚óè")))
#+end_src

** Increase the size of various heading


#+begin_src emacs-lisp
(set-face-attribute 'org-document-title nil :font default-variable-pitch-font :weight 'bold :height 1.3)
(dolist (face '((org-level-1 . 1.3)
                (org-level-2 . 1.25)
                (org-level-3 . 1.2)
                (org-level-4 . 1.15)
                (org-level-5 . 1.1)
                (org-level-6 . 1.05)
                (org-level-7 . 1)
                (org-level-8 . 1.0)))
  (set-face-attribute (car face) nil :font default-variable-pitch-font :weight 'medium :height (cdr face)))
#+end_src

** Close org mode configuration
#+begin_src emacs-lisp
  )
#+end_src

** Setting monospace fonts for required text
#+begin_src emacs-lisp
(require 'org-indent)
(set-face-attribute 'org-block nil :foreground nil :inherit 'fixed-pitch)
(set-face-attribute 'org-table nil  :inherit 'fixed-pitch)
(set-face-attribute 'org-formula nil  :inherit 'fixed-pitch)
(set-face-attribute 'org-code nil   :inherit '(shadow fixed-pitch))
(set-face-attribute 'org-date nil :inherit 'fixed-pitch)
(set-face-attribute 'org-indent nil :inherit '(org-hide fixed-pitch))
(set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
(set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
(set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
(set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch)
#+end_src

** Custom function
This functions allows to search across the org roam note in any directory. To
call them, you should use the ~SPC-o-s~ shortcuts
#+begin_src emacs-lisp
  ;; function to search into the org folder
  (defun lem/org-search ()
    (interactive)
    (counsel-rg "" org-directory nil "Search notes: "))
#+end_src

** Org templates

In this subsection, I will add some capture to the capture list, that are not   
related with any workflow 
#+begin_src emacs-lisp
  (add-to-list 'org-capture-templates
  `("m" "Fondos" table-line                                        
                   (file+headline ,(expand-file-name "Metrics.org" org-directory) "Fondos")
                   "| %U | %^{fondo1} | %^{fondo2} |" :kill-buffer t) t)
#+end_src

** Org-auto-tangle
Org  auto-tangle enable tangle the content of a document each time, you save the
org file. You need to add the option ~#+auto_tangle: t~ in the header of the file
#+begin_src emacs-lisp

    (use-package org-auto-tangle
      :defer t
      :hook (org-mode . org-auto-tangle-mode)
      :config
      (setq org-auto-tangle-default nil))

    (defun lem/insert-auto-tangle-tag ()
      "Insert auto-tangle tag in literature config."
      (interactive)
      (evil-org-open-below 1)
      (insert "#+auto_tangle: t ")
      (evil-force-normal-state))

#+end_src

* Org roam

Org-roam is a tool for networked thought. It reproduces some of the Roam
Research‚Äôs key features within Org-mode.

*** Installation
The instalation process use the melpa or melpa stable package manager from emacs.

#+begin_src emacs-lisp
    (use-package org-roam
      :custom
      (org-roam-directory (expand-file-name "roam" org-directory))
      (org-roam-dailies-capture-templates
       '(("d" "default" entry "* %<%I:%M %p>: %?"
          :if-new (file+head+olp "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>\n\n* Time Managment\n#+BEGIN: clocktable :scope agenda :maxlevel 6 :block %<%Y-%m-%d>\n#+CAPTION: \n#+END:" ("Notes")))))
      :bind (("C-c n l" . org-roam-buffer-togle)
             ("C-c n f" . org-roam-node-find)
             ("C-c n i" . org-roam-node-insert)
             ("C-c n I" . org-roam-node-insert-immediate)
             :map org-mode-map
             ("C-M-i" . completion-at-point)
             :map org-roam-dailies-map
             ("Y" . org-roam-dailies-capture-yesterday)
             ("T" . org-roam-dailies-capture-tomorrow))
      :bind-keymap
      ("C-c n d" . org-roam-dailies-map)
      :config
      (require 'org-roam-dailies) ;; Ensure the keymap is available
      ;;Autosync mode allows to keep track and cache all changes to maintain cache consistency. Also this configuration parameter was moved to the package declaration
      (org-roam-db-autosync-mode)
      ;; refresh agenda list after load org-roam
      (my/org-roam-refresh-agenda-list)
#+end_src

lso the org roam is not close
*** Configure org roam templates
#+begin_src emacs-lisp
(setq org-roam-capture-templates
 '(("f" "Fleeting" plain "%?"
     :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+TITLE: ${title}\n#+DATE: %U\n#+AUTHOR: %n\n#+filetags: fleeting")
     :unnarrowed nil)
   ("d" "default" plain "%?"
    :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+date: %U\n#+author: %n\n")
    :unnarrowed t)
   ("p" "project" plain "* Goals\n\n%?\n\n* Tasks\n\n** TODO Add initial tasks\n\n* Dates\n\n"
    :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+category: ${title}\n#+filetags: Project")
    :unnarrowed t)))
#+end_src

*** Configure org roam completion

If you‚Äôre using a vertical completion framework, such as Ivy, Org-roam supports
the generation of an aligned, tabular completion interface. For example, to
include a column for tags, one can set org-roam-node-display-template as such:

#+begin_src emacs-lisp
(setq org-roam-node-display-template
      (concat "${title:*} "
              (propertize "${tags:*}" 'face 'org-tag)))
#+end_src

*** End of org roam
#+begin_src emacs-lisp
)
#+end_src

*** Some functions used for customize org-roam
#+begin_src emacs-lisp
  (defun my/org-roam-filter-by-tag (tag-name)
    (lambda (node)
      (member tag-name (org-roam-node-tags node))))

  (defun my/org-roam-list-notes-by-tag (tag-name)
    (mapcar #'org-roam-node-file
            (seq-filter
             (my/org-roam-filter-by-tag tag-name)
             (org-roam-node-list))))
  (defun my/org-roam-refresh-agenda-list ()
    (interactive)
    (setq org-agenda-files (delete-dups (append org-agenda-files (my/org-roam-list-notes-by-tag "Project")))))

  (defun my/org-roam-find-project ()
    (interactive)
    ;; Add the project file to the agenda after capture is finished
    (add-hook 'org-capture-after-finalize-hook #'my/org-roam-project-finalize-hook)

    ;; Select a project file to open, creating it if necessary
    (org-roam-node-find
     nil
     nil
     (lambda (node)
       (member "Project" (org-roam-node-tags node)))))
  (defun org-roam-node-insert-immediate (arg &rest args)
    (interactive "P")
    (let ((args (push arg args))
          (org-roam-capture-templates (list (append (car org-roam-capture-templates)
                                                    '(:immediate-finish t)))))
      (apply #'org-roam-node-insert args)))
  (defun my/org-roam-capture-task ()
    (interactive)
    (org-roam-capture- :node (org-roam-node-read
                              nil
                              (my/org-roam-filter-by-tag "Project"))
                       :templates '(
                                    ("p" "project" plain "** TODO %?"
                                     :if-new (file+head+olp "%<%Y%m%d%H%M%S>-${slug}.org"
                                                            "#+title: ${title}\n#+category: ${title}\n#+filetags: Project"
                                                            ("Tasks")))
                                    ("s" "start now" entry "** TODO %?"
                                     :if-new (file+head+olp "%<%Y%m%d%H%M%S>-${slug}.org"
                                                            "#+title: ${title}\n#+category: ${title}\n#+filetags: Project"
                                                            ("Tasks"))
                                     :clock-in :clock-resume)
                                    ("m" "Meeting")
                                    ("mp" "Prepare meeting" entry "** Notes\n %?"
                                     :if-new (file+head+olp "%<%Y%m%d%H%M%S>-${slug}.org"
                                                            "#+title: ${title}\n#+category: ${title}\n#+filetags: Project"
                                                            ("Meetings"))
                                     :target (file+olp+datetree "%<%Y%m%d%H%M%S>-${slug}.org" ("Meetings"))))))
#+end_src


** Zettelkasten
The zettelkasten methodology offers a set of rules to help you to organize your
notes in a way that makes them easy to find. It is based on the idea of
establishing links between atomic concepts (each note). On this way, breaks the
traditional hierarchical structure based on folders and makes it easier to
relate concepts

There are 4 kind of notes:

*** 1. Fleeting notes
Fleeting notes are thinkings, ideas, concepts and sketch of future notes. They
need to be processed and related with another notes. To make it simple, the name
of this notes has a prefix with the current date and time, so can be many notes
with the same ‚Äútitle‚Äù. This method make easy not be distracted by the title
instead of the concept.

#+begin_src emacs-lisp :tangle no
  ; I move the definition of this template to the org-roam package declaration
  ; because when it run, the org-roam package is not full load
  (add-to-list 'org-roam-capture-templates
               '("f" "Fleeting" plain "%?"
                 :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+TITLE: ${title}\n#+DATE: %U\n#+AUTHOR: %n\n#+filetags: fleeting")
                 :unnarrowed nil))
#+end_src

*** 2. Literature Notes
Literature notes are notes extracted from external source. These must include                                                                                                                                      
the reference. These notes have summary or/and highlight from the source, and if
it is possible, tray to indicate:                                               
                                                                                
1. Why this content is relevant?                                                
2. When you read the source?                                                    
3. In which content do you think it can be useful?                              
                                                                                
To answer this question, you can use meta-data as header from of the note, a    
link to the project/area which you think that can be useful and a link to       
another note with the explanation. This allows you to keep separate the original
content to your conclusion and ideas.

#+begin_src emacs-lisp
(setq bibliography-files '("~/Documents/Org/bibliography.bib"
                             "~/Documents/Org/phd.bib"))
(use-package ivy-bibtex
  :config
  (setq bibtex-completion-bibliography bibliography-files))

  (use-package org-ref                                                                                                                                                                                             
    :init (require 'bibtex)                                                     
    :config (setq bibtex-autokey-year-length 4                                  
                  bibtex-autokey-name-year-separator "-"                        
                  bibtex-autokey-year-title-separator "-"                       
                  bibtex-autokey-titleword-separator "-"                        
                  bibtex-autokey-titlewords 2                                   
                  bibtex-autokey-titlewords-stretch 1                           
                  bibtex-autokey-titleword-length 5                             
                  org-ref-glsentries '("~/Documents/Org/roam/glossary.tex"))    
    (define-key bibtex-mode-map (kbd "H-b") 'org-ref-bibtex-hydra/body)         
    (define-key org-mode-map (kbd "C-c ]") 'org-ref-insert-link)                
    (define-key org-mode-map (kbd "s-[") 'org-ref-insert-link-hydra/body)       
    (require 'org-ref-ivy)                                                      
    (require 'org-ref-sci-id)                                                   
    (require 'org-ref-arxiv)                                                    
    (require 'org-ref-scopus)                                                   
    (require 'org-ref-pubmed)                                                   
    (require 'org-ref-wos)                                                      
    (setq org-ref-insert-link-function 'org-ref-insert-link-hydra/body    
                org-ref-insert-cite-function 'org-ref-cite-insert-ivy           
                org-ref-insert-label-function 'org-ref-insert-label-link        
                org-ref-insert-ref-function 'org-ref-insert-ref-link            
                org-ref-cite-onclick-function (lambda (_)                       
                  (org-ref-citation-hydra/body))))
#+end_src
**** Citar                                                                       
                                                                                
[[https://github.com/emacs-citar/citar][Citar]] provides a highly-configurable completing-read front-end to browse and act
on BibTeX, BibLaTeX, and CSL JSON bibliographic data, and LaTeX, markdown, and  
org-cite editing support.                                                       
                                                                                
#+begin_src emacs-lisp
  (use-package citar                                                            
    :custom                                                                     
    (citar-bibliography bibliography-files))                                    
#+end_src                                                                       

****** citar-org-roam                                                              
                                                                                
This package use citar as base to improve the citation process.                 
                                                                                
#+begin_src emacs-lisp
  (use-package org-roam-bibtex :after org-roam)                                 
  (use-package citar-org-roam                                                   
    :after (citar org-roam)                                                      
    :config                                                                      
    (citar-org-roam-mode)                                                        
    (citar-register-notes-source 'orb-citar-source                               
                                 (list :name "Org-Roam Notes"                                                
                                       :category 'org-roam-node                                                   
                                       :items #'citar-org-roam--get-candidates                                    
                                       :hasitems #'citar-org-roam-has-notes                                       
                                       :open #'citar-org-roam-open-note                                           
                                       :create #'orb-citar-edit-note                                              
                                       :annotate #'citar-org-roam--annotate))                                     
    (setq citar-notes-source 'orb-citar-source)                                 

  (setq citar-org-roam-note-title-template "${author} - ${title}")              
  (add-to-list 'org-roam-capture-templates                                      
               '("r" "bibliography reference" plain "%?"                        
                 :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org"                                                                                                                                                  
                                    "#+TITLE: ${title}\n#+AUTHOR: ${author}\n#+filetags: Literature\n#+cite-key: ${citekey}\n#+cite-date: ${date} \n#+created: %U\n\n* ${title}\n\n")
                 :unnarrowed t) t)                                              
  (setq citar-org-roam-capture-template-key "r"))                                
#+end_src   

***** Import annotations from Zotero                                              
                                                                                
#+begin_src emacs-lisp
  (defun lem/import-notes-from-zotero (citekey)                                 
  (interactive "sCiteKey: ")                                                    
    (let* ((entry (bibtex-completion-get-entry citekey))                        
           (note (bibtex-completion-get-value "note" entry ""))                 
           (pandoc-command "pandoc --from latex --to org")                      
           result)                                                              
      (with-temp-buffer                                                         
        (shell-command (format "echo \"%s\" | %s" note pandoc-command)          
                       (current-buffer))                                        
        (setq result (buffer-substring-no-properties (point-min) (point-max)))) 
      (insert result)))                                                         
#+end_src                                                                       
                                                                                
I need if I add a new acronym, this will not be added only on the top of the    
current buffer, such happens with org-ref. I need the acronym or the glossary   
entry will be added into the list with all the acronyms.                        
                                                                                
#+begin_src emacs-lisp                                                          
  (defun lem/add-acronym (label abbrv full)                                     
    (interactive "sLabel: \nsAccronym: \nsFull text: ")                         
    (save-excursion                                                             
      (re-search-backward "#\\+latex_header" nil t)                             
      (forward-line)                                                            
      (when (not (looking-at "^$"))                                             
        (beginning-of-line)                                                     
        (insert "\n")                                                           
        (forward-line -1))                                                      
      (insert (format "#+latex_header_extra: \\newacronym{%s}{%s}{%s}\n"        
                      label abbrv full))                                        
      (write-region                                                             
       (format                                                                  
        "\\newacronym{%s}{%s}{%s}\n"                                            
        label abbrv full)                                                       
       nil "~/Documents/Org/roam/glossary.tex" 'append)))                       
                                                                                
#+end_src

*** 3. Permanent Notes
Permanent notes are stand-alone ideas, that can be made without any direct      
context to other sourced. Can be made as a recap or summary of the information, 
but also can be thoughts that popped into your brain while you are working.     
                                                                                
The aim of permanent notes is to process the notes you have made and extract    
ideas, related content and any kind of useful information for you. 

*** 4. Index Notes
Index notes are these notes used to group connected notes. Can be a TOC, a sort 
description, or whatever you want.

** Org-roam-ui

#+begin_src emacs-lisp
(use-package org-roam-ui)
#+end_src

