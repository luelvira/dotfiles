#+TITLE: My Org config
#+DATE: 2023-11-19 Sun
#+AUTHOR: Lucas Elvira Martín
* Table Of Content                                                      :TOC:
- [[#put-this-in-your-initel][PUT THIS IN YOUR init.el]]
- [[#package-system-setup][Package system setup]]
  - [[#enable-straight][Enable straight]]
  - [[#startup-performance][Startup performance]]
- [[#keep-it-clean][Keep it clean]]
- [[#custom-library][Custom library]]
- [[#set-encoding-by-default][Set encoding by default]]
- [[#disable-warnings][Disable warnings]]
- [[#autorun][AUTORUN]]
  - [[#emacs-as-server][Emacs as server]]
- [[#keyboard-binding][Keyboard binding]]
  - [[#esc-as-c-g][ESC as C-g]]
  - [[#rebind-c-u][Rebind C-u]]
  - [[#set-up-evil-mode][Set up evil mode]]
  - [[#which-key][Which Key]]
  - [[#generalel][General.el]]
- [[#ui][UI]]
  - [[#reduce-distraction][Reduce distraction]]
  - [[#maximize-window-by-default][Maximize window by default]]
  - [[#transparency][Transparency]]
  - [[#enable-line-numbers][Enable line numbers]]
  - [[#ignore-warning-messages-when-following-symlinks][Ignore warning messages when following symlinks]]
  - [[#collor-theme][Collor Theme]]
  - [[#fonts][Fonts]]
  - [[#better-modeline][Better Modeline]]
  - [[#auto-revert-buffer][Auto revert buffer]]
  - [[#toggle-display-white-space][Toggle display white space]]
  - [[#highlight-matching-parentheses][Highlight matching parentheses]]
- [[#editing-configuration][Editing configuration]]
  - [[#tramp][Tramp]]
  - [[#tab-widths][Tab widths]]
  - [[#commenting-lines][Commenting lines]]
- [[#configuration-files][Configuration files]]
- [[#customize-shortcuts][Customize shortcuts]]
  - [[#bookmarks-and-buffer][Bookmarks and buffer]]
- [[#completion-system][Completion system]]
  - [[#ivy-and-counsel][ivy and counsel]]
  - [[#helpul][helpul]]
- [[#file-browsing-with-dired][File Browsing with dired]]
  - [[#keybinding-within-dired][Keybinding within dired]]
  - [[#keybinding-for-peep-dired-mode][Keybinding for peep-dired-mode]]
  - [[#open-files-externally][Open files externally]]
  - [[#files][Files]]
- [[#writting][Writting]]
  - [[#tools][Tools]]
  - [[#text-mode][Text mode]]
  - [[#org-mode][Org mode]]
  - [[#org-roam-mode][Org roam mode]]
  - [[#pdfs][PDFs]]
- [[#dashboard][Dashboard]]
- [[#terminal-emulator][Terminal emulator]]
  - [[#vterm][vterm]]
- [[#development][Development]]
  - [[#projectile][Projectile]]
  - [[#magit][Magit]]
  - [[#github-copilot][Github copilot]]
  - [[#languages][Languages]]
- [[#applications][Applications]]
  - [[#calendar][Calendar]]

* PUT THIS IN YOUR init.el

#+begin_example
(org-babel-load-file
(expand-file-name
"config.org"
  user-emacs-directory))
#+end_example
Also, turn on lexical-binding for the init file!

#+begin_src emacs-lisp
;; -*- lexical-binding: t; -*-
;(server-start)
#+end_src

* Package system setup

Emacs has a built in package manager but it doesn’t make it easy to automatically install packages
on a new system the first time you pull down your configuration. [[https:github.com/jwiegley/use-package][use-package]] is a really helpful
package used in this configuration to make it a lot easier to automate the installation and
configuration of everything else we use.

#+begin_src emacs-lisp

(require 'package)
(setq package-archives '(("melpa" . "https://melpa.org/packages/")
                         ("melpa-stable" . "https://stable.melpa.org/packages/")
                         ("org" . "https://orgmode.org/elpa/")
                         ("elpa" . "https://elpa.gnu.org/packages/")))

(package-initialize)

(unless (package-installed-p 'use-package)
  (package-install 'use-package))
(require 'use-package)
(setq use-package-always-ensure t)
#+end_src

** Enable straight

#+begin_src emacs-lisp
;; Bootstrap straight.el
(defvar bootstrap-version)
(let ((bootstrap-file
      (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
        "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
        'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))

;; Always use straight to install on systems other than Linux
(setq straight-use-package-by-default (not (eq system-type 'gnu/linux)))

;; Use straight.el for use-package expressions
(straight-use-package 'use-package)

;; Clean up unused repos with `straight-remove-unused-repos'
#+end_src

** Startup performance

Make startup faster by reducing the frequency of garbage collection and then use
a hook to measure Emacs startup time.

#+begin_src emacs-lisp
(use-package gcmh
:config
(gcmh-mode 1))
;; Setting garbage collection threshold
(setq gc-cons-threshold (* 50 1000 1000)
    gc-cons-percentage 0.6)
;; Profile emacs startup
(add-hook 'emacs-startup-hook
        (lambda ()
            (message "*** Emacs loaded in %s with %d garbage collections."
                    (format "%.2f seconds"
                            (float-time
                            (time-subtract after-init-time before-init-time)))
                    gcs-done)))

#+end_src

* Keep it clean
First I define the default emacs back-up where all the cache files will be
stored

#+begin_src emacs-lisp
;; Change the user-emacs-directory to keep unwanted things out of ~/.emacs.d
(setq user-emacs-directory (expand-file-name "~/.cache/emacs/")
      url-history-file (expand-file-name "url/history" user-emacs-directory))
;;
;; Use no-littering to automatically set common paths to the new user-emacs-directory

(use-package no-littering)
#+end_src

Then define where will be store the temporal files

#+begin_src emacs-lisp
(setq backup-directory-alist '(("." . "~/.cache/emacs/backup/"))
  backup-by-copying t    ; Don't delink hardlinks
  version-control t      ; Use version numbers on backups
  delete-old-versions t  ; Automatically delete excess backups
  kept-new-versions 20   ; how many of the newest versions to keep
  kept-old-versions 5    ; and how many of the old
  )
#+end_src

* Custom library

I would like to make this configuration as modular as possible, so I will break it up into multiples
files. With that in mind, I add a directory to the path.

#+begin_src emacs-lisp
(push "~/Documents/git/dotfiles/emacs.d/lisp" load-path)
#+end_src

* Set encoding by default
#+begin_src emacs-lisp
(set-default-coding-systems 'utf-8)
#+end_src

* Disable warnings
The first time emacs is open, display a lot of annoying warnings. To prevent
this, use ~native-comp-async-report-warnings-errors~
#+begin_src emacs-lisp
(setq native-comp-async-report-warnings-errors nil)
#+end_src

* AUTORUN
** Emacs as server

This command allow to run emacs as server, so all the startup can be done once
time and connect client to it each time you need.

#+begin_src emacs-lisp
  (server-start)
#+end_src

*** Connect a client
To connect a client to the server you need to run

#+begin_example shell
emacsclient --create-frame --alternate-editor=""
 or use an alias
export ALTERNATE_EDITOR=""
export EDITOR="emacsclient -t"                  # $EDITOR opens in terminal
export VISUAL="emacsclient -c -a emacs"         # $VISUAL opens in GUI mode
#+end_example
* Keyboard binding

** ESC as C-g

#+begin_src emacs-lisp
(global-set-key (kbd "<escape>") 'keyboard-escape-quit)
#+end_src

** Rebind C-u

#+begin_src emacs-lisp
(global-set-key (kbd "C-M-u") 'universal-argument)
#+end_src

** Set up evil mode
Evil mode is a mayor mode that allow to use vim keybindings in emacs

#+begin_src emacs-lisp
  ;; Define a hook to prevent evil mode be load in some modes
  (defun lem/evil-custom-state ()
    (dolist (mode '(custom-mode
                    eshell-mode
                    git-rebase-mode
                    erc-mode
                    circe-server-mode
                    circe-chat-mode
                    circe-query-mode
                    sauron-mode
                    term-mode))
    (add-to-list 'evil-emacs-state-modes mode)))

  (defun rune/dont-arrow-me-bro ()
    (interactive)
    (message "Arrow keys are bad, you know?"))

  (use-package undo-tree
    :init
    (global-undo-tree-mode 1)
  :config
  (setq undo-tree-auto-save-history nil))
#+end_src
*** Install evil mode

This configuration uses [[https://evil.readthedocs.io/en/latest/index.html][evil-mode]] for a Vi-like modal editing experience.
[[https://github.com/noctuid/general.el][general.el]] is used for easy keybinding configuration that integrates well with
which-key.  [[https://github.com/emacs-evil/evil-collection][evil-collection]] is used to automatically configure various Emacs
modes with Vi-like keybindings for evil-mode.
#+begin_src emacs-lisp

  (use-package evil
   :init
   (setq evil-want-integration t
        evil-want-keybinding nil
        evil-want-C-u-scroll t
        evil-want-C-i-jump t
        evil-undo-system 'undo-tree
        evil-respect-visual-line-mode t)
   :config
   (add-hook 'evil-mode-hook 'lem/evil-custom-state)
   (evil-mode 1)
   (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state)
   (define-key evil-insert-state-map (kbd "C-h") 'evil-delete-backward-char-and-join)
   (evil-set-initial-state 'messages-buffer-mode 'normal)
   (evil-set-initial-state 'dashboard-mode 'normal)
  ; (evil-set-initial-state 'term-mode 'emacs)

    ;;; Disable arrow keys in insert mode
    (define-key evil-insert-state-map (kbd "<left>") 'rune/dont-arrow-me-bro)
    (define-key evil-insert-state-map (kbd "<right>") 'rune/dont-arrow-me-bro)
    (define-key evil-insert-state-map (kbd "<down>") 'rune/dont-arrow-me-bro)
    (define-key evil-insert-state-map (kbd "<up>") 'rune/dont-arrow-me-bro))
#+end_src

*** Install evil-collection
Evil collection is a package that provide evil keybindings for a lot of modes

#+begin_src emacs-lisp
  (use-package evil-collection
    :after evil
    :custom
    (evil-collection-outline-bind-tab-p nil)
    :config
    (evil-collection-init))


  (use-package evil-numbers
    :after evil
    :hook 'lem/evil-mode-number-hook)

  (define-key evil-normal-state-map (kbd "C-a +") 'evil-numbers/inc-at-pt)
  (define-key evil-normal-state-map (kbd "C-a -") 'evil-numbers/dec-at-pt)
  (define-key evil-normal-state-map (kbd "C-a g +") 'evil-numbers/inc-at-pt-incremental)
  (define-key  evil-normal-state-map (kbd "C-a g -") 'evil-numbers/dec-at-pt-incremental)

  (use-package evil-surround
    :ensure t
    :config
    (global-evil-surround-mode 1))

#+end_src


** Which Key

[[https://github.com/justbur/emacs-which-key][which-key]] is a useful UI panel that appears when you start pressing any key binding in Emacs to
offer you all possible completions for the prefix.  For example, if you press =C-c= (hold control
and press the letter =c=), a panel will appear at the bottom of the frame displaying all of the
bindings under that prefix and which command they run.  This is very useful for learning the
possible key bindings in the mode of your current buffer.

#+begin_src emacs-lisp
(use-package which-key
  :init (which-key-mode)
  :diminish which-key-mode
  :config
  (setq which-key-idle-delay 0.3))
#+end_src

** General.el

#+begin_src emacs-lisp
(use-package general
  :config
  (general-evil-setup t)

  (general-create-definer lem/leader-key-def
    :keymaps '(normal insert visual emacs)
    :prefix "SPC"
    :global-prefix "C-SPC"))
#+end_src

* UI

This section configures basic UI settings that remove unneded elements to make Emacs look a lot more minimal and modern.
** Reduce distraction

#+begin_src emacs-lisp
  (setq inhibit-startup-message t)
  (scroll-bar-mode -1)        ; Disable visible scrollbar
  (tool-bar-mode -1)          ; Disable the toolbar
  (tooltip-mode -1)           ; Disable tooltips
  (set-fringe-mode 0)        ; Give some breathing room (menu-bar-mode -1)            ; Disable the menu bar
  (menu-bar-mode -1)
  ;; Set up the visible bell
  (setq visible-bell t)
  (electric-indent-mode -1)
  (electric-pair-mode -1)

#+end_src

** Maximize window by default
#+begin_src emacs-lisp
(set-frame-parameter (selected-frame) 'fullscreen 'maximized)
(add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src

** Transparency

#+begin_src emacs-lisp
(unless (string= (getenv "DESKTOP_SESSION") "gnome")
    (set-frame-parameter nil 'alpha '(90 . 90))
    (add-to-list 'default-frame-alist '(alpha-background . 90)))
#+end_src

** Enable line numbers
#+begin_src emacs-lisp
(column-number-mode)

;; Enable line numbers for some modes
(dolist (mode '(text-mode-hook
                prog-mode-hook
                conf-mode-hook))
  (add-hook mode (lambda () (display-line-numbers-mode 1))))
#+end_src
** Ignore warning messages when following symlinks

#+begin_src emacs-lisp
(setq vc-follow-symlinks t)
#+end_src

** Collor Theme

[[https://github.com/hlissner/emacs-doom-themes][doom-themes]] is a great set of themes with a lot of variety and support for many different Emacs
modes.  Taking a look at the [[https://github.com/hlissner/emacs-doom-themes/tree/screenshots][screenshots]] might help you decide which one you like best.  You can
also run =M-x counsel-load-theme= to choose between them easily.

#+begin_src emacs-lisp
(use-package spacegray-theme :defer t)
(use-package doom-themes :defer t)
(load-theme 'doom-dracula t)
(doom-themes-visual-bell-config)
#+end_src

** Fonts

#+begin_src emacs-lisp
      ;; Set the font
    (setq default-mono-font "Fira Code"
          default-variable-pitch-font "Noto Sans Mono")
    (set-face-attribute 'default nil
        :font default-mono-font
        :height 110)
    (set-face-attribute 'fixed-pitch nil
      :family default-mono-font :height 1.0 :inherit 'default)
    (set-face-attribute 'variable-pitch nil
      :family default-variable-pitch-font :weight 'regular :inherit 'default)
#+end_src

*** Ligatures
#+begin_src emacs-lisp
  (use-package ligature
  :config
  (ligature-set-ligatures 't '("www"))
  ;; Enable traditional ligature support in eww-mode, if the
  ;; `variable-pitch' face supports it
  (ligature-set-ligatures 'eww-mode '("ff" "fi" "ffi"))
  ;; Enable all Cascadia Code ligatures in programming modes
  (ligature-set-ligatures 'prog-mode '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
                                       ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
                                       "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
                                       "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
                                       "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
                                       "..." "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
                                       "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
                                       "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
                                       ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
                                       "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
                                       "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
                                       "?=" "?." "??" ";;" "/*" "/=" "/>" "//" "__" "~~" "(*" "*)"
                                       "\\\\" "://"))
  ;; Enables ligature checks globally in all buffers. You can also do it
  ;; per mode with `ligature-mode'.
  (global-ligature-mode t))
#+end_src


** Better Modeline

[[https://github.com/seagle0128/doom-modeline][doom-modeline]] is a very attractive and rich (yet still minimal) mode line
configuration for Emacs.  The default configuration is quite good but you can
check out the [[https://github.com/seagle0128/doom-modeline#customize][configuration options]] for more things you can enable or disable.

*NOTE:* The first time you load your configuration on a new machine, you'll need
to run `M-x all-the-icons-install-fonts` so that mode line icons display
correctly.

#+begin_src emacs-lisp
  (setq display-time-format "%H:%M %b %y"
        display-time-default-load-average nil)
  (display-time-mode 1)
  ;; Dimish modeline clutter hides pesky minor modes
  (use-package diminish)

  ;; All the icons
  (use-package all-the-icons)
  (use-package minions
    :hook (doom-modeline-mode . minions-mode))

  (use-package doom-modeline
    :init (doom-modeline-mode 1)
    :custom
    (doom-modeline-height 15)
    (doom-modeline-bar-width 0)
    (doom-modeline-minor-modes t)
    (doom-modeline-persp-name nil)
    (doom-modeline-buffer-file-name-style 'truncate-except-project)
    (doom-modeline-major-mode-icon nil))
#+end_src

** Auto revert buffer

#+begin_src emacs-lisp
;; Revert Dired and other buffers
(setq global-auto-revert-non-file-buffers t)

;; Revert buffers when the underlying file has changed
(global-auto-revert-mode 1)
#+end_src

** Toggle display white space

#+begin_src emacs-lisp
(lem/leader-key-def
  "t"  '(:ignore t :which-key "toggles")
  "tw" '(whitespace-mode :which-key "whitespace"))
#+end_src

** Highlight matching parentheses

#+begin_src emacs-lisp
(use-package paren
  :config
  (set-face-attribute 'show-paren-match-expression nil :background "#363e4a")
  (show-paren-mode 1))
#+end_src

* Editing configuration
** Tramp
Tramp is a built-in package that allows you to open files over SSH, su, and sudo
from within Emacs. It’s incredibly useful if you need to edit files as root or
on a remote machine frequently.

#+begin_src emacs-lisp
(use-package tramp
  :defer t
  :config
  (setq tramp-default-method "ssh"))
#+end_src

** Tab widths
Default tab width is 8, which is too much. We can change it to 4.

#+begin_src emacs-lisp
(setq-default tab-width 2)
(setq-default evil-shift-width tab-width)
;; use spaces instead of tabs
(setq-default indent-tabs-mode nil)
#+end_src

** Commenting lines

#+begin_src emacs-lisp
(use-package evil-nerd-commenter
  :bind ("M-/" . evilnc-comment-or-uncomment-lines))
#+end_src

* Configuration files
We can set a sortcut to open the config file from the emacs directory

#+begin_src emacs-lisp
  (lem/leader-key-def
  "fd" '((lambda () (interactive) (counsel-find-file "~/Documents/git/dotfiles")) :which-key "Config")
  "fo" '((lambda () (interactive) (counsel-find-file "~/Documents/Org/")) :which-key "Org files")
  "fe" '(:ignore t :which-key "Emacs Config")
  "fec" '((lambda () (interactive) (find-file "~/Documents/git/dotfiles/.emacs.d/config.org")) :which-key "Emacs Config file")
  "few" '((lambda () (interactive) (find-file "~/Documents/git/dotfiles/.emacs.d/org-workflow.org")) :which-key "Emacs workflow file")
  "fez" '((lambda () (interactive) (find-file "~/Documents/git/dotfiles/.emacs.d/org-zettelkasten.org")) :which-key "Emacs zettel file"))
#+end_src

* Customize shortcuts

** Bookmarks and buffer

Use 'SPC b' for keybinings related to bookmarks and buffers

*** Bookmarks
Bookmarks are somewhat like registers in that they record positions you can jump to.  Unlike registers, they have long names, and they persist automatically from one Emacs session to the next. The prototypical use of bookmarks is to record where you were reading in various files.

| COMMAND         | DESCRIPTION                              | KEYBINDING |
|-----------------+------------------------------------------+------------|
| list-bookmarks  | /List bookmarks/                         | SPC b L    |
| bookmark-set    | /Set bookmark/                           | SPC b m    |
| bookmark-delete | /Delete bookmark/                        | SPC b M    |
| bookmark-save   | /Save current bookmark to bookmark file/ | SPC b w    |

#+begin_src emacs-lisp
  (setq bookmark-default-file (expand-file-name "bookmarks" user-emacs-directory))
  (lem/leader-key-def
  "b" '(:ignore t :which-key "buffers/bookmarks")
  "bL" '(list-bookmarks :which-key "List bookmarks")
  "bm" '(bookmark-set :which-key "Set bookmark")
  "bd" '(bookmark-delete :which-key "Delete bookmark")
  "bw" '(bookmark-save :which-key "Save current bookmark to bookmark file"))

#+end_src

*** Buffers
Regarding /buffers/, the text you are editing in Emacs resides in an object
called a /buffer/. Each time you visit a file, a buffer is used to hold the
file’s text. Each time you invoke Dired, a buffer is used to hold the directory
listing.  /Ibuffer/ is a program that lists all of your Emacs /buffers/,
allowing you to navigate between them and filter them.

| COMMAND               | DESCRIPTION            | KEYBINDING |
|-----------------------+------------------------+------------|
| counsel-switch-buffer | /change Buffer/        | SPC b i    |
| kill-buffer           | /Kill current buffer/  | SPC b k    |
| next-buffer           | /Goto next buffer/     | SPC b n    |
| previous-buffer       | /Goto previous buffer/ | SPC b p    |
| save-buffer           | /Save current buffer/  | SPC b s    |


#+begin_src emacs-lisp
    (lem/leader-key-def
  "bi" '(counsel-switch-buffer :which-key "Counsel switch buffer")
  "bk" '(kill-current-buffer :whick-key "Kill current buffer")
  "bn" '(next-buffer :whick-key "Goto next buffer")
  "bp" '(previous-buffer :whick-key "Goto previous-buffer buffer")
  "bs" '(save-buffer :whick-key "Save current buffer"))
#+end_src

* Completion system

** ivy and counsel

ivy is a generic completion mechanism for Emacs. It is based on the idea of incremental narrowing:
the list of candidates is filtered as you type more characters. It is similar to ido-mode, but is
more powerful and flexible.

[[https://oremacs.com/swiper/][Ivy]] is an excellent completion framework for Emacs.  It provides a minimal yet powerful selection
menu that appears when you open files, switch buffers, and for many other tasks in Emacs.  Counsel
is a customized set of commands to replace `find-file` with `counsel-find-file`, etc which provide
useful commands for each of the default completion commands.

[[https://github.com/Yevgnen/ivy-rich][ivy-rich]] adds extra columns to a few of the Counsel commands to provide more information about each
item.
#+begin_src emacs-lisp
  (use-package hydra
    :defer 1)

  (use-package ivy
    :diminish
    :bind (("C-s" . swiper)
           :map ivy-minibuffer-map
           ("TAB" . ivy-alt-done)
           ("C-l" . ivy-alt-done)
           ("C-j" . ivy-next-line)
           ("C-k" . ivy-previous-line)
           :map ivy-switch-buffer-map
           ("C-k" . ivy-previous-line)
           ("C-l" . ivy-done)
           ("C-d" . ivy-switch-buffer-kill)
           :map ivy-reverse-i-search-map
           ("C-k" . ivy-previous-line)
           ("C-d" . ivy-reverse-i-search-kill))
    :init
    (ivy-mode 1)
    :config
    (setq ivy-use-virtual-buffers t)
    (setq ivy-wrap t)
    (setq ivy-count-format "(%d/%d) ")
    (setq enable-recursive-minibuffers t)
    (setf (alist-get 'counsel-projectile-ag ivy-height-alist) 15)
    (setf (alist-get 'counsel-projectile-rg ivy-height-alist) 15)
    (setf (alist-get 'swiper ivy-height-alist) 15)
    (setf (alist-get 'counsel-switch-buffer ivy-height-alist) 7))

  (lem/leader-key-def
    "C-S" '(counsel-projectile-grep :which-key "Projectile grep"))


  (use-package ivy-hydra
    :defer t
    :after hydra)

  (use-package ivy-rich
    :init
    (ivy-rich-mode 1)
    :after counsel
    :config
    (setq ivy-format-function #'ivy-format-function-line)
    (setq ivy-rich-display-transformers-list
          (plist-put ivy-rich-display-transformers-list
                     'ivy-switch-buffer
                     '(:columns
                       ((ivy-rich-candidate (:width 40))
                        (ivy-rich-switch-buffer-indicators (:width 4 :face error :align right)); return the buffer indicators
                        (ivy-rich-switch-buffer-major-mode (:width 12 :face warning))          ; return the major mode info
                        (ivy-rich-switch-buffer-project (:width 15 :face success))             ; return project name using `projectile'
                        (ivy-rich-switch-buffer-path (:width (lambda (x) (ivy-rich-switch-buffer-shorten-path x (ivy-rich-minibuffer-width 0.3))))))  ; return file path relative to project root or `default-directory' if project is nil
                       :predicate
                       (lambda (cand)
                         (if-let ((buffer (get-buffer cand)))
                             ;; Don't mess with EXWM buffers
                             (with-current-buffer buffer
                               (not (derived-mode-p 'exwm-mode)))))))))
#+end_src

*** Counsel
Counsel need to be installed before ivy. Also, Counsel provides ivy and swipper
as dependencies, but I will install ivy manually

#+begin_src emacs-lisp

  (use-package counsel
    :demand t
    :bind (("M-x" . counsel-M-x)
           ("C-x b" . counsel-switch-buffer)
           ("C-x C-f" . counsel-find-file)
           ;; ("C-M-j" . counsel-switch-buffer)
           ("C-M-l" . counsel-imenu)
           :map minibuffer-local-map
           ("C-r" . 'counsel-minibuffer-history))
    :custom
    (counsel-linux-app-format-function #'counsel-linux-app-format-function-name-only)
    :config
    (setq ivy-initial-inputs-alist nil)) ;; Don't start searches with ^
#+end_src

*** Disable '^' of M-x

The following line removes the annoying ‘^’ in things like counsel-M-x and
other ivy/counsel prompts.  The default ‘^’ string means that if you type
something immediately after this string only completion candidates that begin
with what you typed are shown.  Most of the time, I’m searching for a command
without knowing what it begins with though.

#+begin_src emacs-lisp
(setq ivy-initial-inputs-alist nil)
#+end_src

*** Install Smex

Smex is a package that makes M-x remember out history

#+begin_src emacs-lisp
(use-package smex)
(smex-initialize)
#+end_src

*** Orderless

Orderless improves candidate filtering create pattern by words separate with
spaces and display any command which has the same words in any order

#+begin_src emacs-lisp
(use-package orderless
  :ensure t
  :custom
  (completion-styles '(orderless basic))
  (completion-category-overrides '((file (styles basic partial-completion)))))
#+end_src

***  Better completion options with company-mode

Company is a Modular text completion framework for emacs

#+begin_src emacs-lisp
  (use-package company
  :after lsp-mode
  :hook (prog-mode . company-mode)
  :custom
  (company-begin-commands '(self-insert-command))
  (company-idle-delay .1)
  (company-minimum-prefix-length 2)
  (company-show-numbers t)
  (company-tooltip-align-annotations 't)
  (global-company-mode t))

  (use-package company-box
    :hook (company-mode . company-box-mode))
#+end_src

*** Snippets
#+begin_src emacs-lisp
  (use-package yasnippet
    :hook (prog-mode . yas-minor-mode)
    :config
    (yas-reload-all))
#+end_src

** helpul

[[https://github.com/Wilfred/helpful][Helpful]] adds a lot of very helpful (get it?) information to Emacs' =describe-= command buffers.  For
example, if you use =describe-function=, you will not only get the documentation about the function,
you will also see the source code of the function and where it gets used in other places in the
Emacs configuration.  It is very useful for figuring out how things work in Emacs.


#+begin_src emacs-lisp
(use-package helpful
  :custom
  (counsel-describe-function-function #'helpful-callable)
  (counsel-describe-variable-function #'helpful-variable)
  :bind
  ([remap describe-function] . counsel-describe-function)
  ([remap describe-command] . helpful-command)
  ([remap describe-variable] . counsel-describe-variable)
  ([remap describe-key] . helpful-key))
#+end_src

* File Browsing with dired

| Command    | Description                     | KEYBINDING |
|------------+---------------------------------+------------|
| dired      | open dired                      | SPC d d    |
| dired-jump | open dired at current directory | SPC d j    |

** Keybinding within dired

| Command                   | Description                  | KEYBINDING |
|---------------------------+------------------------------+------------|
| dired-single-up-directory | go to the previous directory | h          |
| dired-omit-mode           | Toggle ommit mode            | H          |
| dired-single-buffer       |                              |            |

** Keybinding for peep-dired-mode

| Command              | Description    | KEYBINDING |
|----------------------+----------------+------------|
| peep-dired           | Toggle preview | SPC d p    |
| peep-dired-next-file | Next file      | n          |
| peep-dired-prev-file | Previous file  | p          |

#+begin_src emacs-lisp
  (use-package all-the-icons-dired)
  (use-package dired
    :ensure nil
    :defer 1
    :config
    (setq dired-listing-swithces "--group-directories-first"
          dired-omit-files "^\\.[^.].*"
          delete-by-moving-to-trash t)
    (autoload 'dired-omit-mode "dired-x")
    (add-hook 'dired-load-hook
              (lambda ()
                (interactive)
                (dired-collapse)))
    (add-hook 'dired-mode-hook
              (lambda () (interactive)
                (dired-omit-mode 1)
                (dired-hide-details-mode 1)
                (all-the-icons-dired-mode 1)
                (hl-line-mode 1)))

  (use-package dired-single
    :defer t)

  (use-package dired-ranger
    :defer t)

  (use-package dired-collapse
    :defer t)

  (evil-collection-define-key 'normal 'dired-mode-map
    "h" 'dired-single-up-directory
    "H" 'dired-omit-mode
    "l" 'dired-single-buffer
    "y" 'dired-ranger-copy
    "X" 'dired-ranger-move
    "p" 'dired-ranger-paste))

#+end_src

** Open files externally

** Files
| Command           | Description          | shortcut |
|-------------------+----------------------+----------|
| counsel-recentf   | Display recent files | r        |
| lem/delete-file   | Delete current file  | D        |
| counsel-find-file | Find files in CW     | f        |


Emacs by default does not have a system to delete the current file. But you can
use the delete-file function with the buffer-file-name

#+begin_src emacs-lisp
  (defun lem/delete-file ()
    "Delete the current file and kill the buffer"
    (interactive)
    (let ((filename (buffer-file-name)))
      (if filename
          (if (y-or-n-p (concat "Do you really want to delete file " filename "?"))
              (progn (delete-file filename)
                     (message "File delete")
                     (kill-buffer)))
        (message "Not a file visiting buffer!"))))

#+end_src

#+begin_src emacs-lisp
  (lem/leader-key-def
    "f" '(:ignore t :which-key  "Files")
    "fr" '(counsel-recentf :which-key "Recent files")
    "fD" '(lem/delete-file :which-key "Delete current file")
    "ff" '(counsel-find-file :which-key "Find files"))
#+end_src

* Writting

** Tools
*** Configure flyspell

Fly spell is a mode that allows you to see typing errors. By default it is disable, but can be
configure to be used on different kinds of situations.

#+begin_src emacs-lisp
  (use-package flyspell
      :config
      (setq ispell-program-name "hunspell"
            ispell-default-dictionary "en_US")
      :hook (text-mode . flyspell-mode)
      :bind (("M-<f7>" . flyspell-buffer)
             ("<f7>" . flyspell-word)
             ("C-;" . flyspell-auto-correct-previous-word)))
#+end_src

**** Toggle dictionaries

#+begin_src emacs-lisp
  (defun lem/switch-dictionary()
  (interactive)
  (let* ((dic ispell-current-dictionary)
     (change (if (string= dic "en_US") "es_ES" "en_US")))
    (ispell-change-dictionary change)
    (message "Dictionary switched from %s to %s" dic change)
    ))

  (global-set-key (kbd "<f8>")   'lem/switch-dictionary)
#+end_src

**** Install language tool

Language tool is a software that check both, grammar and spelling in different
languages.

***** Install the binary

#+begin_src shell
curl https://languagetool.org/download/LanguageTool-stable.zip -o /tmp/LanguageTool-stable.zip
mkdir -p ~/.local/lib/
unzip /tmp/LanguageTool-stable.zip -d ~/.local/lib/languageTool
#+end_src

#+begin_src emacs-lisp
  (use-package langtool
     :config
     (setq langtool-language-tool-jar "~/.local/lib/languageTool/LanguageTool-6.3/languagetool-commandline.jar"
  langtool-default-language "en-US"))
#+end_src

*** Visual fill configuration

#+begin_src emacs-lisp
  ;; Wrap the text in a custom column size
  (defun lem/org-mode-visual-fill ()
    (setq visual-fill-column-width 100
          fill-column 80
          visual-fill-column-center-text t))

  (use-package visual-fill-column
    :defer t
    :hook (text-mode . lem/org-mode-visual-fill))
#+end_src

*** Sync my files
I have a script which try to keep sync with a repository on codeberg. This repo
contains the org files only, and it is named sync.

#+begin_src emacs-lisp
  (defun lem/sync (path)
    (shell-command-to-string (format "/home/lucas/.local/bin/sync.sh %s" path)))

  (defun lem/sync-org ()
  "Sync the Org foler with an external script"
  (interactive)
  (lem/sync "~/Documents/Org"))

  (defun lem/sync-conf ()
  "Sync the config foler with an external script"
(interactive)
(lem/sync "~/Documents/git/dotfiles"))

  ;; (add-hook 'after-save-hook 'lem/sync) Use as hook generate a lot of commits
#+end_src
** Text mode
Aditionaly to the last hook I will make more adjustement into the text view

#+begin_src emacs-lisp
  (defun lem/text-mode-setup ()
    (variable-pitch-mode 1)
    (auto-fill-mode 1)
    (visual-fill-column-mode 1)
    (setq evil-auto-indent nil))

  (add-hook 'text-mode-hook 'lem/text-mode-setup)
#+end_src

** Org mode

#+begin_src emacs-lisp
  (defun lem/org-mode-hook ()
    (org-indent-mode)
      (diminish org-indent-mode))

  (use-package org
  :hook (org-mode . lem/org-mode-hook)
  :config
  (setq org-directory "~/Documents/Org/"
        org-default-notes-file (concat org-directory "Inbox.org")
        org-ellipsis " ▾"
        org-superstar-headline-bullets-list '("◉" "●" "○" "◆" "●" "○" "◆")
        org-superstar-item-bullet-alist '((?- . ?➤) (?+ . ?✦)) ; changes +/- symbols in item lists
        org-log-done 'time
        org-hide-emphasis-markers nil
        org-table-convert-region-max-lines 20000
        org-src-fontify-natively t
        org-fontify-quote-and-verse-blocks t
        org-src-tab-acts-natively t
        org-edit-src-content-indentation 2
        org-hide-block-startup nil
        org-src-preserve-indentation nil
        org-cycle-separator-lines 2
        org-refile-targets '((nil :maxlevel . 2)
                            (org-agenda-files :maxlevel . 1))
        org-outline-path-complete-in-steps nil
        org-refile-use-outline-path t)

#+end_src

The org mode is not close

*** GTD
**** Multiple  keyword sets in one file
From the [[https://orgmode.org/manual/Multiple-sets-in-one-file.html][org manual]], sometimes you want to use different sets of TODO keywords in parallel. For
example a set for task that could be =DONE= or =TODO=, other task that could depends on other and
include the keyword =WAITING= and so on.

IMPORTANT* You can only use set at time, so you need first to select the correct workflow. The
shortcut to select them is: =C-u C-u C-c C-t=;  =C-s-RIGHT=;  =C-s-LEFT=

****  Workflow states
- *TODO*: A task which should be done, but is not processed
- *NEXT*: With the GTD flow, the next task to be done
- *WAIT*: This task depends on other person, so it's not actionable
- *DONE*: Need explication?

#+begin_src emacs-lisp
  (setq org-todo-keywords
        '((sequence "TODO(t)" "NEXT(n)" "WAIT(w)" "|" "DONE(d!)" "CANCELED(c!)")))
#+end_src

**** Tags

Tags helps to filter over all task. This task are mutually exclusive, allowing to determinate its context.
- *batch* Low effort
- *followup* Someone is waiting on me to finish this task
#+begin_src emacs-lisp
  (setq org-tag-alist
      '((:startgroup . nil)
       ;Put mutually exclusive tags here
       ("@home" . ?H )
       ("@PHD" . ?P)
       ("@UI" . ?U)
       (:endgroup . nil)))
#+end_src

**** Priorities

#+begin_src emacs-lisp
  (setq org-fancy-priorities-list '("🟥" "🟧" "🟨")
        org-priority-faces
        '((?A :foreground "#ff6c6b" :weight bold)
          (?B :foreground "#98be65" :weight bold)
          (?C :foreground "#c678dd" :weight bold))
        org-agenda-block-separator 8411)
#+end_src

**** Agendas
Configure the agenda views

#+begin_src emacs-lisp
  (setq org-agenda-files
        (mapcar (lambda (file) (concat org-directory file)) '("Tasks.org" "Habits.org"))
        org-agenda-window-setup 'current-window
        org-agenda-span 'week
        org-agenda-start-with-log-mode t
        org-log-into-drawer t
        org-columns-default-format "%20CATEGORY(Category) %30ITEM(Task) %4TODO %6Effort(Estim){:} %20SCHEDULED %20DEADLINE %6CLOCKSUM(Clock) %TAGS")
#+end_src

Org agenda is a mode of emacs that allows you to view the task for the week

Note 1* You can shcedule the todos with org-shedule command or due time with
org-deadline. To move around the date use ~Shift+arrows~


Note 2*: We can get a repeat item ading to the deadline the period of time to
be repeat, for example a birthday that is repeat each year (see the agenda file)

**** Control time per task

Emacs give you a way to capture the time you spends on each task. You only need
go over the task and execute the command =org-clock-in= and when you stop or
finish go again over the task and run =org-clock-out=

#+begin_src emacs-lisp
  (setq org-clock-persist 'history)
  (org-clock-persistence-insinuate)
#+end_src

**** Capture template for task
The following templates should be used to customize the behavior of the capture
process for new tasks.

#+begin_src emacs-lisp
  (setq org-capture-templates
        `(("t" "Tasks")
          ("tt" "Task" entry (file+olp+datetree ,(concat org-directory "Tasks.org"))
           "* TODO %?\n  %i" :empty-lines 1)
          ("tm" "Meeting" entry (file+headline ,(concat org-directory "Tasks.org") "Meeting")
           "* %? :meeting:\n<%<%Y-%m-%d %a %H:00>>")
        ("tn" "Note" entry (file ,(concat org-directory "notes.org"))
         "* Note (%a)\nEntered on %U\n%?")))
#+end_src

**** Pomodoro
#+begin_src emacs-lisp
(use-package org-pomodoro
    :ensure t
    :after org
    :config
    (setq
     alert-user-configuration (quote ((((:category . "org-pomodoro")) libnotify nil)))
     org-pomodoro-length 90
     org-pomodoro-short-break-length 10
     org-pomodoro-long-break-length 20
     org-pomodoro-clock-break t
     org-pomodoro-manual-break t))

  (defun set-pomodoro-timer (minutes)
    (interactive "nMinutes: ")
    (setq org-pomodoro-length minutes))

#+end_src

**** Habit

#+begin_src emacs-lisp
  (require 'org-habit)
  (add-to-list 'org-modules 'org-habit)
  (setq org-habit-graph-column 60
        org-habit-show-all-today nil
        org-habit-show-habits-only-for-today nil)
#+end_src
*** Configure Babel languages

To execute or export code in org-mode code blocks, you’ll need to set up org-babel-load-languages
for each language you’d like to use. [[https:orgmode.org/worg/org-contrib/babel/languages/index.html][This page]] documents all of the languages that you can use with
org-babel.

#+begin_src emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (python . t)
   (js . t)
   (shell . t)
   (gnuplot . t)))

(push '("conf-unix" . conf-unix) org-src-lang-modes)
(org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages)
#+end_src

**** Structure templates
Org Mode's [[https://orgmode.org/manual/Structure-Templates.html][structure templates]] feature enables you to quickly insert code blocks into your Org files
in combination with =org-tempo= by typing =<= followed by the template name like =el= or =py= and
then press =TAB=.  For example, to insert an empty =emacs-lisp= block below, you can type =<el= and
press =TAB= to expand into such a block.

You can add more =src= block templates below by copying one of the lines and
changing the two strings at the end, the first to be the template name and the
second to contain the name of the language [[https://orgmode.org/worg/org-contrib/babel/languages.html][as it is known by Org Babel]].
#+begin_src emacs-lisp
  ;; This is needed as of Org 9.2
  (require 'org-tempo)

  (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
  (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("py" . "src python"))
  (add-to-list 'org-structure-template-alist '("js" . "src python"))
  (add-to-list 'org-structure-template-alist '("ex" . "export"))
#+end_src

*** Fonts and bullets
**** Bullets
Use bullet characters instead of asterisks, plus set the header font sizes to something more palatable. A fair amount of inspiration has been taken from [[https://zzamboni.org/post/beautifying-org-mode-in-emacs/][this blog post]].
#+begin_src emacs-lisp
  (use-package org-superstar
  :after org
  :hook (org-mode . org-superstar-mode))
#+end_src

**** Increase the size of various heading
I dont like how it is shown
#+begin_src emacs-lisp :tangle no
;;(set-face-attribute 'org-document-title nil :font default-variable-pitch-font :weight 'bold :height 1.3)
(dolist (face '((org-level-1 . 1.3)
                (org-level-2 . 1.25)
                (org-level-3 . 1.2)
                (org-level-4 . 1.15)
                (org-level-5 . 1.1)
                (org-level-6 . 1.05)
                (org-level-7 . 1)
                (org-level-8 . 1.0)))
  (set-face-attribute (car face) nil :font default-variable-pitch-font :weight 'medium :height (cdr face)))
#+end_src

**** Setting monospace fonts for required text
#+begin_src emacs-lisp
(require 'org-indent)
(set-face-attribute 'org-block nil :foreground nil :inherit 'fixed-pitch)
(set-face-attribute 'org-table nil  :inherit 'fixed-pitch)
(set-face-attribute 'org-formula nil  :inherit 'fixed-pitch)
(set-face-attribute 'org-code nil   :inherit '(shadow fixed-pitch))
(set-face-attribute 'org-date nil :inherit 'fixed-pitch)
(set-face-attribute 'org-indent nil :inherit '(org-hide fixed-pitch))
(set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
(set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
(set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
(set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch)
#+end_src

*** Adding some key binding

#+begin_src emacs-lisp
  ;; function to search into the org folder
  (defun lem/org-search ()
    (interactive)
    (counsel-rg "" org-directory nil "Search notes: "))

;;  (use-package evil-org
;;    :after org
;;    :hook ((org-mode . evil-org-mode)
;;           (org-agenda-mode . evil-org-mode)
;;           (evil-org-mode . (lambda () (evil-org-set-key-theme '(navigation todo insert textobjects additional)))))
;;    :config
;;    (require 'evil-org-agenda)
;;    (evil-org-agenda-set-keys))
;;
  (lem/leader-key-def
    "o" '(:ignore t :which-key "org mode")
    "oi" '(:ignore t :which-key "Insert")
    "oil" '(org-insert-link :which-key "insert link")
    "on"  '(org-toggle-narrow-to-subtree :which-key "toggle narrow")
    "os"  '(lem/org-search :which-key "search notes")
    "oa" '(org-agenda :which-key "Status")
    ;;"ot" '(org-todo-list :which-key "Show TODOs")
    "oc" '(org-capture t :which-key "Capture")
    "op" '(:ignore t :which-key "Pomodoro")
    "ops" '(org-pomodoro :whick-key "Start org pomodoro")
    "opt" '(set-pomodoro-timer :which-key "Set pomodoro timer")) 
#+end_src

*** Close org mode configuration
#+begin_src emacs-lisp
  )
#+end_src

*** Org templates
In this subsection, I will add some capture to the capture list, that are not   
related with any workflow 
#+begin_src emacs-lisp
  (add-to-list 'org-capture-templates
  `("m" "Fondos" table-line                                        
                   (file+headline ,(expand-file-name "Metrics.org" org-directory) "Fondos")
                   "| %U | %^{fondo1} | %^{fondo2} |" :kill-buffer t) t)
#+end_src

*** Org toc
#+begin_src emacs-lisp
  (use-package toc-org                                                          
    :hook (org-mode . toc-org-mode))
#+end_src

*** Org-auto-tangle
Org  auto-tangle enable tangle the content of a document each time, you save the
org file. You need to add the option ~#+auto_tangle: t~ in the header of the file
#+begin_src emacs-lisp

    (use-package org-auto-tangle
      :defer t
      :hook (org-mode . org-auto-tangle-mode)
      :config
      (setq org-auto-tangle-default nil))

    (defun lem/insert-auto-tangle-tag ()
      "Insert auto-tangle tag in literature config."
      (interactive)
      (evil-org-open-below 1)
      (insert "#+auto_tangle: t ")
      (evil-force-normal-state))

  (lem/leader-key-def
    "ia" '(lem/insert-auto-tangle-tag :which-key "Insert auto-tangle header tag"))

#+end_src
** Org roam mode
Org-roam is a tool for networked thought. It reproduces some of the Roam
Research’s key features within Org-mode.

*** Installation
The instalation process use the melpa or melpa stable package manager from emacs.

#+begin_src emacs-lisp
    (use-package org-roam
      :custom
      (org-roam-directory (expand-file-name "roam" org-directory))
      (org-roam-completion-everywhere t)
      (org-roam-dailies-capture-templates
       '(("d" "default" entry "* %<%I:%M %p>: %?"
          :if-new (file+head+olp "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>\n\n* Time Managment\n#+BEGIN: clocktable :scope agenda :maxlevel 6 :block %<%Y-%m-%d>\n#+CAPTION: \n#+END:" ("Notes")))))
      :bind (("C-c n l" . org-roam-buffer-togle)
             ("C-c n f" . org-roam-node-find)
             ("C-c n i" . org-roam-node-insert)
             ("C-c n I" . org-roam-node-insert-immediate)
             :map org-mode-map
             ("C-M-i" . completion-at-point)
             :map org-roam-dailies-map
             ("Y" . org-roam-dailies-capture-yesterday)
             ("T" . org-roam-dailies-capture-tomorrow))
      :bind-keymap
      ("C-c n d" . org-roam-dailies-map)
      :config
      (require 'org-roam-dailies) ;; Ensure the keymap is available
      ;;Autosync mode allows to keep track and cache all changes to maintain cache consistency. Also this configuration parameter was moved to the package declaration
      (org-roam-db-autosync-mode)
      ;; refresh agenda list after load org-roam
      (my/org-roam-refresh-agenda-list)
#+end_src

Also the org roam is not close
*** Configure org roam templates
#+begin_src emacs-lisp
(setq org-roam-capture-templates
 '(("f" "Fleeting" plain "%?"
     :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+TITLE: ${title}\n#+DATE: %U\n#+AUTHOR: %n\n#+filetags: fleeting")
     :unnarrowed nil)
   ("d" "default" plain "%?"
    :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+date: %U\n#+author: %n\n")
    :unnarrowed t)
   ("p" "project" plain "* Goals\n\n%?\n\n* Tasks\n\n** TODO Add initial tasks\n\n* Dates\n\n"
    :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+category: ${title}\n#+filetags: Project")
    :unnarrowed t)))
#+end_src
*** Configure org roam completion

If you’re using a vertical completion framework, such as Ivy, Org-roam supports
the generation of an aligned, tabular completion interface. For example, to
include a column for tags, one can set org-roam-node-display-template as such:

#+begin_src emacs-lisp
(setq org-roam-node-display-template
      (concat "${title:*} "
              (propertize "${tags:*}" 'face 'org-tag)))
#+end_src

*** End of org roam
#+begin_src emacs-lisp
)
#+end_src

*** Some functions used for customize org-roam
#+begin_src emacs-lisp
  (defun my/org-roam-filter-by-tag (tag-name)
    (lambda (node)
      (member tag-name (org-roam-node-tags node))))

  (defun my/org-roam-list-notes-by-tag (tag-name)
    (mapcar #'org-roam-node-file
            (seq-filter
             (my/org-roam-filter-by-tag tag-name)
             (org-roam-node-list))))
  (defun my/org-roam-refresh-agenda-list ()
    (interactive)
    (setq org-agenda-files (delete-dups (append org-agenda-files (my/org-roam-list-notes-by-tag "Project")))))

  (defun my/org-roam-find-project ()
    (interactive)
    ;; Add the project file to the agenda after capture is finished
    (add-hook 'org-capture-after-finalize-hook #'my/org-roam-project-finalize-hook)

    ;; Select a project file to open, creating it if necessary
    (org-roam-node-find
     nil
     nil
     (lambda (node)
       (member "Project" (org-roam-node-tags node)))))

  (defun my/org-roam-capture-task ()
  (interactive)
  (org-roam-capture- :node (org-roam-node-read
                                nil
                                (my/org-roam-filter-by-tag "Project"))
                       :templates '(
                                    ("p" "project" plain "** TODO %?"
                                     :if-new (file+head+olp "%<%Y%m%d%H%M%S>-${slug}.org"
                                                            "#+title: ${title}\n#+category: ${title}\n#+filetags: Project"
                                                            ("Tasks")))
                                    ("s" "start now" entry "** TODO %?"
                                     :if-new (file+head+olp "%<%Y%m%d%H%M%S>-${slug}.org"
                                                            "#+title: ${title}\n#+category: ${title}\n#+filetags: Project"
                                                            ("Tasks"))
                                     :clock-in :clock-resume)
                                    ("m" "Meeting")
                                    ("mp" "Prepare meeting" entry "** Notes\n %?"
                                     :if-new (file+head+olp "%<%Y%m%d%H%M%S>-${slug}.org"
                                                            "#+title: ${title}\n#+category: ${title}\n#+filetags: Project"
                                                            ("Meetings"))
                                     :target (file+olp+datetree "%<%Y%m%d%H%M%S>-${slug}.org" ("Meetings"))))))
#+end_src

*** Keybinding for org-roam
#+begin_src emacs-lisp
  (lem/leader-key-def
    "or"  '(:ignore t :which-key "Org roam")
    "orl" '(org-roam-buffer-togle :which-key "Org roam buffer togle")
    "orf" '(org-roam-node-find :whick-key "Org roam node find")
    "ori" '(org-roam-node-insert :whick-key "Org roam node insert")
    "orI" '(org-roam-node-insert-immediate :which-key "Org roam insert immediately")
    "orc" 'my/org-roam-capture-task)
#+end_src
*** Zettelkasten
The zettelkasten methodology offers a set of rules to help you to organize your
notes in a way that makes them easy to find. It is based on the idea of
establishing links between atomic concepts (each note). On this way, breaks the
traditional hierarchical structure based on folders and makes it easier to
relate concepts

There are 4 kind of notes:

**** 1. Fleeting notes
Fleeting notes are thinkings, ideas, concepts and sketch of future notes. They
need to be processed and related with another notes. To make it simple, the name
of this notes has a prefix with the current date and time, so can be many notes
with the same “title”. This method make easy not be distracted by the title
instead of the concept.

#+begin_src emacs-lisp :tangle no
  ; I move the definition of this template to the org-roam package declaration
  ; because when it run, the org-roam package is not full load
  (add-to-list 'org-roam-capture-templates
               '("f" "Fleeting" plain "%?"
                 :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+TITLE: ${title}\n#+DATE: %U\n#+AUTHOR: %n\n#+filetags: fleeting")
                 :unnarrowed nil))
#+end_src

**** 2. Literature Notes
Literature notes are notes extracted from external source. These must include                                                                                                                                      
the reference. These notes have summary or/and highlight from the source, and if
it is possible, tray to indicate:                                               
                                                                                
1. Why this content is relevant?                                                
2. When you read the source?                                                    
3. In which content do you think it can be useful?                              
                                                                                
To answer this question, you can use meta-data as header from of the note, a    
link to the project/area which you think that can be useful and a link to       
another note with the explanation. This allows you to keep separate the original
content to your conclusion and ideas.

#+begin_src emacs-lisp
(setq bibliography-files '("~/Documents/Org/bibliography.bib"
                             "~/Documents/Org/phd.bib"))
(use-package ivy-bibtex
  :config
  (setq bibtex-completion-bibliography bibliography-files))

  (use-package org-ref                                                                                                                                                                                             
    :init (require 'bibtex)                                                     
    :config (setq bibtex-autokey-year-length 4                                  
                  bibtex-autokey-name-year-separator "-"                        
                  bibtex-autokey-year-title-separator "-"                       
                  bibtex-autokey-titleword-separator "-"                        
                  bibtex-autokey-titlewords 2                                   
                  bibtex-autokey-titlewords-stretch 1                           
                  bibtex-autokey-titleword-length 5                             
                  org-ref-glsentries '("~/Documents/Org/roam/glossary.tex"))    
    (define-key bibtex-mode-map (kbd "H-b") 'org-ref-bibtex-hydra/body)         
    (define-key org-mode-map (kbd "C-c ]") 'org-ref-insert-link)                
    (define-key org-mode-map (kbd "s-[") 'org-ref-insert-link-hydra/body)       
    (require 'org-ref-ivy)                                                      
    (require 'org-ref-sci-id)                                                   
    (require 'org-ref-arxiv)                                                    
    (require 'org-ref-scopus)                                                   
    (require 'org-ref-pubmed)                                                   
    (require 'org-ref-wos)                                                      
    (setq org-ref-insert-link-function 'org-ref-insert-link-hydra/body    
                org-ref-insert-cite-function 'org-ref-cite-insert-ivy           
                org-ref-insert-label-function 'org-ref-insert-label-link        
                org-ref-insert-ref-function 'org-ref-insert-ref-link            
                org-ref-cite-onclick-function (lambda (_)                       
                  (org-ref-citation-hydra/body))))
#+end_src
***** Citar                                                                       
                                                                                
[[https://github.com/emacs-citar/citar][Citar]] provides a highly-configurable completing-read front-end to browse and act
on BibTeX, BibLaTeX, and CSL JSON bibliographic data, and LaTeX, markdown, and  
org-cite editing support.                                                       
                                                                                
#+begin_src emacs-lisp
  (use-package citar                                                            
    :custom                                                                     
    (citar-bibliography bibliography-files))                                    
#+end_src                                                                       

****** citar-org-roam                                                              
                                                                                
This package use citar as base to improve the citation process.                 
                                                                                
#+begin_src emacs-lisp
  (use-package org-roam-bibtex :after org-roam)                                 
  (use-package citar-org-roam                                                   
    :after (citar org-roam)                                                      
    :config                                                                      
    (citar-org-roam-mode)                                                        
    (citar-register-notes-source 'orb-citar-source                               
                                 (list :name "Org-Roam Notes"                                                
                                       :category 'org-roam-node                                                   
                                       :items #'citar-org-roam--get-candidates                                    
                                       :hasitems #'citar-org-roam-has-notes                                       
                                       :open #'citar-org-roam-open-note                                           
                                       :create #'orb-citar-edit-note                                              
                                       :annotate #'citar-org-roam--annotate))                                     
    (setq citar-notes-source 'orb-citar-source)                                 

  (setq citar-org-roam-note-title-template "${author} - ${title}")              
  (add-to-list 'org-roam-capture-templates                                      
               '("r" "bibliography reference" plain "%?"                        
                 :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org"                                                                                                                                                  
                                    "#+TITLE: ${title}\n#+AUTHOR: ${author}\n#+filetags: Literature\n#+cite-key: ${citekey}\n#+cite-date: ${date} \n#+created: %U\n\n* ${title}\n\n")
                 :unnarrowed t) t)                                              
  (setq citar-org-roam-capture-template-key "r"))                                
#+end_src   

***** Import annotations from Zotero                                              
                                                                                
#+begin_src emacs-lisp
  (defun lem/import-notes-from-zotero (citekey)                                 
  (interactive "sCiteKey: ")                                                    
    (let* ((entry (bibtex-completion-get-entry citekey))                        
           (note (bibtex-completion-get-value "note" entry ""))                 
           (pandoc-command "pandoc --from latex --to org")                      
           result)                                                              
      (with-temp-buffer                                                         
        (shell-command (format "echo \"%s\" | %s" note pandoc-command)          
                       (current-buffer))                                        
        (setq result (buffer-substring-no-properties (point-min) (point-max)))) 
      (insert result)))                                                         
#+end_src                                                                       
                                                                                
I need if I add a new acronym, this will not be added only on the top of the    
current buffer, such happens with org-ref. I need the acronym or the glossary   
entry will be added into the list with all the acronyms.                        
                                                                                
#+begin_src emacs-lisp                                                          
  (defun lem/add-acronym (label abbrv full)                                     
    (interactive "sLabel: \nsAccronym: \nsFull text: ")                         
    (save-excursion                                                             
      (re-search-backward "#\\+latex_header" nil t)                             
      (forward-line)                                                            
      (when (not (looking-at "^$"))                                             
        (beginning-of-line)                                                     
        (insert "\n")                                                           
        (forward-line -1))                                                      
      (insert (format "#+latex_header_extra: \\newacronym{%s}{%s}{%s}\n"        
                      label abbrv full))                                        
      (write-region                                                             
       (format                                                                  
        "\\newacronym{%s}{%s}{%s}\n"                                            
        label abbrv full)                                                       
       nil "~/Documents/Org/roam/glossary.tex" 'append)))                       
                                                                                
#+end_src

**** 3. Permanent Notes
Permanent notes are stand-alone ideas, that can be made without any direct      
context to other sourced. Can be made as a recap or summary of the information, 
but also can be thoughts that popped into your brain while you are working.     
                                                                                
The aim of permanent notes is to process the notes you have made and extract    
ideas, related content and any kind of useful information for you. 

**** 4. Index Notes
Index notes are these notes used to group connected notes. Can be a TOC, a sort 
description, or whatever you want.

*** Org-roam-ui

#+begin_src emacs-lisp
(use-package org-roam-ui)
#+end_src

** PDFs
[[https://github.com/vedang/pdf-tools][pdf-tools]] is a replacement of DocView for viewing PDF files inside Emacs.  It
uses the ~poppler~ library, which also means that =pdf-tools= can by used to
modify PDFs.  I use to disable ‘display-line-numbers-mode’ in ‘pdf-view-mode’
because line numbers crash it.

#+begin_src emacs-lisp
(use-package pdf-tools
  :defer t
  :commands (pdf-loader-install)
  :mode "\\.pdf\\'"
  :bind (:map pdf-view-mode-map
              ("j" . pdf-view-next-line-or-next-page)
              ("k" . pdf-view-previous-line-or-previous-page)
              ("C-=" . pdf-view-enlarge)
              ("C--" . pdf-view-shrink))
  :init (pdf-loader-install)
  :config (add-to-list 'revert-without-query ".pdf"))

;;(add-hook 'pdf-view-mode-hook #'dt/turn-off-line-numbers)
(add-hook 'pdf-view-mode-hook #'(lambda () (interactive) (display-line-numbers-mode -1)))
#+end_src
* Dashboard
Emacs Dashboard is an extensible startup screen showing you recent files,
bookmarks, agenda items and an Emacs banner.

#+begin_src emacs-lisp
  (use-package dashboard
      :ensure t
      :init      ;; tweak dashboard config before loading it
      (setq dashboard-set-heading-icons t)
      (setq dashboard-set-file-icons t)
      (setq dashboard-banner-logo-title "Emacs Is More Than A Text Editor!")
      ;;(setq dashboard-startup-banner 'logo) ;; use standard emacs logo as banner
      ;;(setq dashboard-startup-banner "~/.emacs.d/emacs-dash.png")  ;; use custom image as banner
      (setq dashboard-center-content nil) ;; set to 't' for centered content
      (setq dashboard-icon-type 'all-the-icons)
      (setq dashboard-items '((recents . 5)
                  (agenda . 5 )
                  (bookmarks . 3)
                  (projects . 5)
                  (registers . 3)))
      :config
      (dashboard-setup-startup-hook)
      (dashboard-modify-heading-icons '((recents . "file-text")
                        (bookmarks . "book"))))
    ; ensure emacs open in dashboard
    (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
#+end_src

* Terminal emulator

** vterm
vterm enables the use of fully-fledged terminal applications within Emacs so
that I don't need an external terminal emulator.

It need to be compiled, so you need to install first some dependencies
#+begin_src shell
  apt install make cmake libterm-bin libterm
#+end_src

#+begin_src emacs-lisp
  (use-package vterm
    :commands vterm
    :config
    (setq vterm-max-scrollback 10000))

  (add-to-list 'display-buffer-alist
               '("\*vterm\*"
                 (display-buffer-in-side-window)
                 (window-height . 0.25)
                 (side . bottom)
                 (slot . 0)))
  ;;Still does not work
  (add-hook 'vterm-mode-hook 'evil-emacs-state)
  (add-hook 'term-mode-hook 'evil-emacs-state)

#+end_src

* Development

** Projectile

#+begin_src emacs-lisp
    (use-package projectile
      :diminish projectile-mode
      :demand t
      :bind-keymap
      ("C-c p" . projectile-command-map)
      :config (projectile-mode)
      (projectile-register-project-type 'npm '("package.json")
                                        :project-file "package.json"
                                        :compile "npm install"
                                        :test "npm test"
                                        :run "npm start"
                                        :test-suffix ".spec")
      :init
      (setq projectile-switch-project-action #'projectile-dired))

    (use-package counsel-projectile
      :after projectile
      :bind (("C-M-p" . counsel-projectile-find-file))
      :config
      (counsel-projectile-mode))

    (lem/leader-key-def
      "p"  '(:ignore t :which-key "Projectile")
      "pf" '(projectile-find-file :which-key "Projectile find file")
      "ps" '(projectile-switch-project :which-key "Projectile switch project")
      "pF" '(counsel-projectile-rg :which-key "Rip grep")
      "pc" '(projectile-compile-project :which-key "Compile Project")
      "pd" '(projectile-dired :which-key "Projectile dired")
      "pp" '(counsel-projetile :which-key "Counsel projectile"))
#+end_src

** Magit

#+begin_src emacs-lisp
  (use-package magit
    :commands (magit-status magit-get-current-branch)
    :custom
    (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))
#+end_src

*** Magit TODOs
This extension display all the comments with the word TODO inside the project

#+begin_src emacs-lisp
(use-package magit-todos :defer t)
#+end_src

*** Git gutter
Git gutter is a software which make easy to view the difference between a file and the last commit from the same file

#+begin_src emacs-lisp
    (use-package git-gutter
      :ensure t
      :diminish
      :hook ((prog-mode . git-gutter-mode)
             (text-mode . git-gutter-mode))
      :config
      (setq git-gutter:update-interval 0.2))

    (use-package git-gutter-fringe
      :ensure t
      :config
      (define-fringe-bitmap 'git-gutter-fr:added [224] nil nil '(center repeated))
      (define-fringe-bitmap 'git-gutter-fr:modified [224] nil nil '(center repeated))
      (define-fringe-bitmap 'git-gutter-fr:deleted [128 192 224 240] nil nil 'bottom))
#+end_src

*** Ediff

~ediff~ is a diff program that is built into Emacs.  By default, ‘ediff’ splits
files vertically and places the ‘help’ frame in its own window.  I have changed
this so the two files are split horizontally and the ~help~ frame appears as a
lower split within the existing window.  Also, I create my own ‘dt-ediff-hook’
where I add ~j/k~ for moving to next/prev diffs.  By default, this is set to
~n/p~.
#+begin_src emacs-lisp
(setq ediff-split-window-function 'split-window-horizontally
      ediff-window-setup-function 'ediff-setup-windows-plain)

(defun dt-ediff-hook ()
  (ediff-setup-keymap)
  (define-key ediff-mode-map "j" 'ediff-next-difference)
  (define-key ediff-mode-map "k" 'ediff-previous-difference))

(add-hook 'ediff-mode-hook 'dt-ediff-hook)
#+end_src
** Github copilot
Github copilot use OpenAI Codex to suggest code. There is not an emacs' version,
but there is an alternative based in the [[https://github.com/github/copilot.vim][official vim]] binaries
#+begin_src emacs-lisp
  (use-package copilot
    :straight (:host github :repo "zerolfx/copilot.el" :files ("dist" "*.el"))
    :ensure t)

(define-key copilot-completion-map (kbd "<tab>") 'copilot-accept-completion)
(define-key copilot-completion-map (kbd "TAB") 'copilot-accept-completion)
#+end_src

** Languages
*** Language Server protocol

#+begin_src emacs-lisp
  (use-package lsp-mode
    :straight t
    :commands lsp
    :bind (:map lsp-mode-map
                ("TAB" . completion-at-point))
    :custom (lsp-headerline-breadcrumb-enable t))

  (lem/leader-key-def
    "l"  '(:ignore t :which-key "lsp")
    "ld" 'xref-find-definitions
    "lr" 'xref-find-references
    "ln" 'lsp-ui-find-next-reference
    "lp" 'lsp-ui-find-prev-reference
    "ls" 'counsel-imenu
    "le" 'lsp-ui-flycheck-list
    "lS" 'lsp-ui-sideline-mode
    "lX" 'lsp-execute-code-action)

  (use-package lsp-ui
    :straight t
    :hook (lsp-mode . lsp-ui-mode)
    :config
    (setq lsp-ui-sideline-enable t)
    (setq lsp-ui-sideline-show-hover nil)
    (setq lsp-ui-doc-position 'bottom)
    (lsp-ui-doc-show))
#+end_src

*** Debug Adapter Support

#+begin_src emacs-lisp :tangle no
(use-package dap-mode
  :straight t
  :custom
  (lsp-enable-dap-auto-configure nil)
  :config
  (dap-ui-mode 1)
  (dap-tooltip-mode 1)
  (require 'dap-node)
  (dap-node-setup))
#+end_src

*** TypeScript and JavaScript

Configure TypeScript and JavaScript language modes

#+begin_src emacs-lisp
  (use-package typescript-mode
    :mode "\\.ts\\'"
    :config
    (setq typescript-indent-level 4))

  (defun lem/set-js-indentation ()
    (setq js-indent-level 4)
    (setq evil-shift-width js-indent-level)
    (setq-default tab-width 4))

  (use-package js2-mode
    :mode "\\.jsx?\\'"
    :config
    ;; Use js2-mode for Node scripts
    (add-to-list 'magic-mode-alist '("#!/usr/bin/env node" . js2-mode))

    ;; Don't use built-in syntax checking
    (setq js2-mode-show-strict-warnings nil)

    ;; Set up proper indentation in JavaScript and JSON files
    (add-hook 'js2-mode-hook #'lem/set-js-indentation))

;;  (use-package apheleia
;;    :config
;;    (apheleia-global-mode +1))
;;
;;  (use-package prettier-js
;;    :config
;;    (setq prettier-js-show-errors nil))
#+end_src

*** HTML/CSS mode

Configure web mode
#+begin_src emacs-lisp
    (use-package web-mode
      :config
      (setq-default web-mode-code-indent-offset 2)
      (setq-default web-mode-markup-indent-offset 2)
      (setq-default web-mode-attribute-indent-offset 2))

    (use-package rainbow-delimiters :hook (prog-mode . rainbow-delimiters-mode))
    (use-package smartparens :hook (prog-mode . smartparens-mode))

  (defun lem/html-as-prog ()
    (interactive)
              (variable-pitch-mode 0)
              (auto-fill-mode 0)
              (visual-fill-column-mode 0))
(add-hook 'html-mode-hook 'lem/html-as-prog)

#+end_src

Rainbow mode allows to set the background of HTML color strings
#+begin_src emacs-lisp
(use-package rainbow-mode
  :defer t
  :hook (web-mode))
#+end_src

Combine httpd server with impatient mode

#+begin_src emacs-lisp
;; 1. Start the server with `httpd-start'
;; 2. Use `impatient-mode' on any buffer
(use-package impatient-mode :straight t)
#+end_src

*** Python

#+begin_src emacs-lisp
  (use-package python-mode
    :ensure t
    :hook (python-mode . lsp-deferred)
    :custom
    (python-shell-interpreter "python3"))
#+end_src

Install lsp

#+begin_src shell
pip install --user "python-language-server[all]"
#+end_src

In debian system:
#+begin_src shell
sudo apt install python3-pylsp python3-pytest pylint python3-pyflakes
#+end_src

For virtualenv

#+begin_src emacs-lisp
(use-package pyvenv
  :config
  (pyvenv-mode 1))
#+end_src

*** Compilation

Set up the compile package and ensure that compilation output automatically scrolls.

#+begin_src emacs-lisp
(use-package compile
  :straight nil
  :custom
  (compilation-scroll-output t))

(defun auto-recompile-buffer ()
  (interactive)
  (if (member #'recompile after-save-hook)
      (remove-hook 'after-save-hook #'recompile t)
    (add-hook 'after-save-hook #'recompile nil t)))
#+end_src

*** Productivity

**** Syntax checking with flycheck
#+begin_src emacs-lisp
(use-package flycheck
    :ensure t
    :defer t
    :diminish
    :init (global-flycheck-mode))
#+end_src

**** Smart parents
#+begin_src emacs-lisp :tangle no
(use-package smartparens
  :hook (prog-mode . smartparens-mode))
#+end_src

