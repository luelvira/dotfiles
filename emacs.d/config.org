#+AUTHOR: Lucas Elvira
#+DATE 2023-03-19
#+EXPORTS_FILE_NAME: config.html
#+STARTUP: showeverything
#+TITLE: My emacs configuration

* PUT THIS IN YOUR init.el

#+begin_example
(org-babel-load-file
(expand-file-name
"config.org"
  user-emacs-directory))
#+end_example

* AUTORUN
** Emacs as server

This command allow to run emacs as server, so all the startup can be done once
time and connect client to it each time you need
#+begin_src emacs-lisp
  (server-start)
#+end_src
*** Connect a client
To connect a client to the server you need to run

#+begin_example shell
emacsclient --create-frame --alternate-editor=""
 or use an alias
export ALTERNATE_EDITOR=""
export EDITOR="emacsclient -t"                  # $EDITOR opens in terminal
export VISUAL="emacsclient -c -a emacs"         # $VISUAL opens in GUI mode
#+end_example

* Package system setup

Emacs has a built in package manager but it doesn’t make it easy to automatically install packages
on a new system the first time you pull down your configuration. [[https:github.com/jwiegley/use-package][use-package]] is a really helpful
package used in this configuration to make it a lot easier to automate the installation and
configuration of everything else we use.
#+begin_src emacs-lisp

    (require 'package)
    (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
    (add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/") t)
    (add-to-list 'package-archives '("gnu" . "https://elpa.gnu.org/packages/") t)
    (add-to-list 'package-archives '("org" . "https://orgmode.org/elpa/") t)

    (unless package-archive-contents
      (package-refresh-contents))

    (package-initialize)

    (unless (package-installed-p 'use-package)
      (package-install 'use-package))

    (require 'use-package)
    (setq use-package-always-ensure t)
#+end_src

* Basic UI configuration

This section configures basic UI settings that remove unneded elements to make Emacs look a lot more
minimal and modern.

#+begin_src emacs-lisp
  (scroll-bar-mode -1)        ; Disable visible scrollbar
  (tool-bar-mode -1)          ; Disable the toolbar
  (tooltip-mode -1)           ; Disable tooltips
  (set-fringe-mode 10)        ; Give some breathing room

  (menu-bar-mode -1)            ; Disable the menu bar

  ;; Set up the visible bell
  (setq visible-bell t)


;; set line numbers
   (column-number-mode)
   (global-display-line-numbers-mode t)

  ;; Disable line numbers for some modes
  (dolist (mode '(term-mode-hook
		  shell-mode-hook
		  eshell-mode-hook))
    (add-hook mode (lambda () (display-line-numbers-mode 0))))
#+end_src

** Font configuration

#+begin_src emacs-lisp
  (set-face-attribute 'default nil
                      :font "Fira Code"
                      :height 100
                      :weight 'regular)
  ;; Makes commented text and keywords italics.
  ;; This is working in emacsclient but not emacs.
  ;; Your font must have an italic face available.
  (set-face-attribute 'font-lock-comment-face nil
  :slant 'italic)
  (set-face-attribute 'font-lock-keyword-face nil
  :slant 'italic)
#+end_src

* Keybinding configuration

This configuration uses [[https://evil.readthedocs.io/en/latest/index.html][evil-mode]] for a Vi-like modal editing experience.  [[https://github.com/noctuid/general.el][general.el]] is used for easy keybinding configuration that integrates well with which-key.  [[https://github.com/emacs-evil/evil-collection][evil-collection]] is used to automatically configure various Emacs modes with Vi-like keybindings for evil-mode.

  
#+begin_src emacs-lisp
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)
  ;; Set the fixed pitch face
  (use-package general
    :config
    (general-create-definer lucas/leader-keys
      :keymaps '(normal insert visual emacs)
      :prefix "SPC"
      :global-prefix "C-SPC"))

  (lucas/leader-keys
   "t"  '(:ignore t :which-key "toggles"))

 (use-package evil
        :init
        (setq evil-want-integration t)
        (setq evil-want-keybinding nil)
        (setq evil-want-C-u-scroll t)
        (setq evil-want-C-i-jump nil)
        :config
      (evil-mode 1)
      (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state)
      (define-key evil-insert-state-map (kbd "C-h") 'evil-delete-backward-char-and-join)

      ;; Use visual line motions even outside of visual-line-mode buffers
      (evil-global-set-key 'motion "j" 'evil-next-visual-line)
      (evil-global-set-key 'motion "k" 'evil-previous-visual-line)

      (evil-set-initial-state 'messages-buffer-mode 'normal)
      (evil-set-initial-state 'dashboard-mode 'normal))

    (use-package evil-collection
      :after evil
      :config
      (evil-collection-init))

  (use-package evil-numbers)
  (define-key evil-normal-state-map (kbd "C-a +") 'evil-numbers/inc-at-pt)
  (define-key evil-normal-state-map (kbd "C-c -") 'evil-numbers/dec-at-pt)


#+end_src

* UI configuratoin

** Collor Theme

[[https://github.com/hlissner/emacs-doom-themes][doom-themes]] is a great set of themes with a lot of variety and support for many different Emacs
modes.  Taking a look at the [[https://github.com/hlissner/emacs-doom-themes/tree/screenshots][screenshots]] might help you decide which one you like best.  You can
also run =M-x counsel-load-theme= to choose between them easily.

#+begin_src emacs-lisp
(use-package doom-themes
  :init (load-theme 'doom-dracula t))
#+end_src

** Better Modeline

[[https://github.com/seagle0128/doom-modeline][doom-modeline]] is a very attractive and rich (yet still minimal) mode line configuration for Emacs.  The default configuration is quite good but you can check out the [[https://github.com/seagle0128/doom-modeline#customize][configuration options]] for more things you can enable or disable.

*NOTE:* The first time you load your configuration on a new machine, you'll need to run `M-x all-the-icons-install-fonts` so that mode line icons display correctly.

#+begin_src emacs-lisp
  (use-package all-the-icons)
  (use-package doom-modeline
    :ensure t
    :init (doom-modeline-mode 1)
    :custom ((doom-modeline-height 15)))
#+end_src

** Which Key

[[https://github.com/justbur/emacs-which-key][which-key]] is a useful UI panel that appears when you start pressing any key binding in Emacs to
offer you all possible completions for the prefix.  For example, if you press =C-c= (hold control
and press the letter =c=), a panel will appear at the bottom of the frame displaying all of the
bindings under that prefix and which command they run.  This is very useful for learning the
possible key bindings in the mode of your current buffer.

#+begin_src emacs-lisp
(use-package which-key
  :init (which-key-mode)
  :diminish which-key-mode
  :config
  (setq which-key-idle-delay 1))
#+end_src

** ivy and counsel

ivy is a generic completion mechanism for Emacs. It is based on the idea of incremental narrowing:
the list of candidates is filtered as you type more characters. It is similar to ido-mode, but is
more powerful and flexible.

[[https://oremacs.com/swiper/][Ivy]] is an excellent completion framework for Emacs.  It provides a minimal yet powerful selection
menu that appears when you open files, switch buffers, and for many other tasks in Emacs.  Counsel
is a customized set of commands to replace `find-file` with `counsel-find-file`, etc which provide
useful commands for each of the default completion commands.

[[https://github.com/Yevgnen/ivy-rich][ivy-rich]] adds extra columns to a few of the Counsel commands to provide more information about each
item.


#+begin_src emacs-lisp
(use-package ivy
  :diminish
  :bind (("C-s" . swiper)
         :map ivy-minibuffer-map
         ("TAB" . ivy-alt-done)
         ("C-l" . ivy-alt-done)
         ("C-j" . ivy-next-line)
         ("C-k" . ivy-previous-line)
         :map ivy-switch-buffer-map
         ("C-k" . ivy-previous-line)
         ("C-l" . ivy-done)
         ("C-d" . ivy-switch-buffer-kill)
         :map ivy-reverse-i-search-map
         ("C-k" . ivy-previous-line)
         ("C-d" . ivy-reverse-i-search-kill))
  :config
  (ivy-mode 1))
#+end_src

This are some keybining for changes between buffers

*** Disable '^' of M-x
The following line removes the annoying ‘^’ in things like counsel-M-x and
other ivy/counsel prompts.  The default ‘^’ string means that if you type
something immediately after this string only completion candidates that begin
with what you typed are shown.  Most of the time, I’m searching for a command
without knowing what it begins with though.

#+begin_src emacs-lisp
(setq ivy-initial-inputs-alist nil)
#+end_src

*** Ivy Rich

Is an interface for Ivy that provides more information about the commands

#+begin_src emacs-lisp

  (use-package ivy-rich
    :init
    (ivy-rich-mode 1)
)
#+end_src

*** Counser

#+begin_src emacs-lisp
;;   (use-package counsel
;;     :bind (("M-x" . counsel-M-x)
;;            ("C-x b" . counsel-ibuffer)
;;            ("C-x C-f" . counsel-find-file)
;;            :map minibuffer-local-map
;;            ("C-r" . 'counsel-minibuffer-history)))
;; 
    (use-package counsel
      :bind (("C-M-j" . 'counsel-switch-buffer)
             :map minibuffer-local-map
             ("C-r" . 'counsel-minibuffer-history))
      :config
      (counsel-mode 1))
#+end_src


** helpul

[[https://github.com/Wilfred/helpful][Helpful]] adds a lot of very helpful (get it?) information to Emacs' =describe-= command buffers.  For
example, if you use =describe-function=, you will not only get the documentation about the function,
you will also see the source code of the function and where it gets used in other places in the
Emacs configuration.  It is very useful for figuring out how things work in Emacs.


#+begin_src emacs-lisp
(use-package helpful
  :custom
  (counsel-describe-function-function #'helpful-callable)
  (counsel-describe-variable-function #'helpful-variable)
  :bind
  ([remap describe-function] . counsel-describe-function)
  ([remap describe-command] . helpful-command)
  ([remap describe-variable] . counsel-describe-variable)
  ([remap describe-key] . helpful-key))
#+end_src


** Text Scaling

This is an example of using [[https://github.com/abo-abo/hydra][Hydra]] to design a transient key binding for quickly adjusting the scale
of the text on screen.  We define a hydra that is bound to =C-s t s= and, once activated, =j= and
=k= increase and decrease the text scale.  You can press any other key (or =f= specifically) to exit
the transient key map.

#+begin_src emacs-lisp

  (use-package hydra)

  (defhydra hydra-text-scale (:timeout 4)
    "scale text"
    ("j" text-scale-increase "in")
    ("k" text-scale-decrease "out")
    ("f" nil "finished" :exit t))

  (lucas/leader-keys
    "ts" '(hydra-text-scale/body :which-key "scale text"))

#+end_src

* Initital menu

For the initial screen, I will use a dashboard which contains a resume with the last sessions
** DASHBOARD
Emacs Dashboard is an extensible startup screen showing you recent files, bookmarks, agenda items
and an Emacs banner.

*** Launch dashboard by default when launch emacs

#+begin_src emacs-lisp
(use-package all-the-icons)

  
(use-package dashboard
    :ensure t
    :init      ;; tweak dashboard config before loading it
    (setq dashboard-set-heading-icons t)
    (setq dashboard-set-file-icons t)
    (setq dashboard-banner-logo-title "Emacs Is More Than A Text Editor!")
    ;;(setq dashboard-startup-banner 'logo) ;; use standard emacs logo as banner
    (setq dashboard-startup-banner "~/.emacs.d/emacs-dash.png")  ;; use custom image as banner
    (setq dashboard-center-content nil) ;; set to 't' for centered content
    (setq dashboard-items '((recents . 5)
			    (agenda . 5 )
			    (bookmarks . 3)
			    (projects . 3)
			    (registers . 3)))
    :config
    (dashboard-setup-startup-hook)
    (dashboard-modify-heading-icons '((recents . "file-text")

				      (bookmarks . "book"))))
  ; ensure emacs open in dashboard
  (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
#+end_src

** Startup performance

Check the time to load the configuration

#+begin_src emacs-lisp
(use-package gcmh
:config
(gcmh-mode 1))
;; Setting garbage collection threshold
(setq gc-cons-threshold 402653184
    gc-cons-percentage 0.6)

;; Profile emacs startup
(add-hook 'emacs-startup-hook
        (lambda ()
            (message "*** Emacs loaded in %s with %d garbage collections."
                    (format "%.2f seconds"
                            (float-time
                            (time-subtract after-init-time before-init-time)))
                    gcs-done)))

(setq gc-cons-threshold (* 50 1000 1000))

(defun efs/display-startup-time ()
(message "Emacs loaded in %s with %d garbage collections."
        (format "%.2f seconds"
                (float-time
                    (time-subtract after-init-time before-init-time)))
        gcs-done))

(add-hook 'emacs-startup-hook #'efs/display-startup-time)

#+end_src

* Org mode

The main rason why I changes to emacs

 - To toggle the view of the outlines use ~S+tab~
 - Move a line up or down: ~meta+up/down~
 - [X] Change a list to checklist

*** TODO Insert heading!

 - ~Ctrl+c Ctr+t~ to toggle TODO state
 - You can change the state with Shift+leftright
   

*** Configure Org mode

#+begin_src emacs-lisp

  (defun lucas/org-mode-setup ()
    (org-indent-mode)
    (variable-pitch-mode 0)
    (auto-fill-mode 1)
    (visual-line-mode 0)
    (setq evil-auto-indent nil))

  (defun lucas/org-font-setup ()
    ;; Replace list hyphen with dot
    (font-lock-add-keywords 'org-mode
                            '(("^ *\\([-]\\) "
                               (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•")))))))

  (use-package org
    :hook (org-mode . lucas/org-mode-setup)
    :config
    (setq org-ellipsis " ▾")
    (lucas/org-font-setup))


  (use-package org-bullets
    :after org
    :hook (org-mode . org-bullets-mode)
    :custom
    (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")))
  ;; Set faces for heading levels
  (dolist (face '((org-level-1 . 1.2)
                  (org-level-2 . 1.1)
                  (org-level-3 . 1.05)
                  (org-level-4 . 1.0)
                  (org-level-5 . 1.1)
                  (org-level-6 . 1.1)
                  (org-level-7 . 1.1)
                  (org-level-8 . 1.1))))

;;  (set-face-attribute 'org-block nil :foreground nil :inherit 'fixed-pitch)
;;  (set-face-attribute 'org-code nil   :inherit '(shadow fixed-pitch))
;;  (set-face-attribute 'org-table nil   :inherit '(shadow fixed-pitch))
;;  (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
;;  (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
;;  (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
;;  (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch)

  ;; Wrap the text in a custom column size
  (defun lucas/org-mode-visual-fill ()
    (setq visual-fill-column-width 120
          fill-column 100
          visual-fill-column-center-text t)
    (visual-fill-column-mode 1))
  (use-package visual-fill-column
    :hook (org-mode . lucas/org-mode-visual-fill))
#+end_src

*** Org agenda
Org agenda is a mode of emacs that allows you to view the task for the week

You can shcedule the todos with org-shedule command or due time with org-deadline. To move arrownd
the date use ~Shift+arrows~


The next setting are, 
- Org-log-done: store a register for the timestampt the task is done
- Org-log-into-drawer hidden the log

 We can get a repeat item ading to the deadline the period of time to
  be repeteat, for example a birthday that is repeat each year (see
  the agenda file)

#+begin_src emacs-lisp
    (setq org-agenda-start-with-log-mode t)
    (setq org-log-done 'time)
    (setq org-log-into-drawer t)
    (setq org-agenda-files
          '("~/Documents/Org_EFS/Tasks.org"
            "~/Documents/Org_EFS/Habits.org"))

#+end_src

**** Enable more modes in TODO LIST
By default there is only 2 modes, TODO and DONE. With the following
lines we are enable a new sequence of states
#+begin_src emacs-lisp
  (setq org-todo-keywords
        '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
          (sequence "BACKLOG(b)" "PLAN(p)" "READY(r)" "ACTIVE(a)" "REVIEW(v)" "WAIT(w@/!)" "HOLD(h)" "|" "COMPLETED(c)" "CANC(k@)")))
#+end_src

**** Now we go to setup the agenda view

#+begin_src emacs-lisp
  (setq org-agenda-custom-commands
     '(("d" "Dashboard"
       ((agenda "" ((org-deadline-warning-days 7)))
        (todo "NEXT"
          ((org-agenda-overriding-header "Next Tasks")))
        (tags-todo "agenda/ACTIVE" ((org-agenda-overriding-header "Active Projects")))))

      ("n" "Next Tasks"
       ((todo "NEXT"
          ((org-agenda-overriding-header "Next Tasks")))))

      ("W" "Work Tasks" tags-todo "+work-email")

      ;; Low-effort next actions
      ("e" tags-todo "+Effort<15&+Effort>0"
       ((org-agenda-overriding-header "Low Effort Tasks")
        (org-agenda-max-todos 20)
        (org-agenda-files org-agenda-files)))

;; This is a custom workflow states. You can change it to addapt to your workflow
      ("w" "Workflow Status"
       ((todo "WAIT"
              ((org-agenda-overriding-header "Waiting on External")
               (org-agenda-files org-agenda-files)))
        (todo "REVIEW"
              ((org-agenda-overriding-header "In Review")
               (org-agenda-files org-agenda-files)))
        (todo "PLAN"
              ((org-agenda-overriding-header "In Planning")
               (org-agenda-todo-list-sublevels nil)
               (org-agenda-files org-agenda-files)))
        (todo "BACKLOG"
              ((org-agenda-overriding-header "Project Backlog")
               (org-agenda-todo-list-sublevels nil)
               (org-agenda-files org-agenda-files)))
        (todo "READY"
              ((org-agenda-overriding-header "Ready for Work")
               (org-agenda-files org-agenda-files)))
        (todo "ACTIVE"
              ((org-agenda-overriding-header "Active Projects")
               (org-agenda-files org-agenda-files)))
        (todo "COMPLETED"
              ((org-agenda-overriding-header "Completed Projects")
               (org-agenda-files org-agenda-files)))
        (todo "CANC"
              ((org-agenda-overriding-header "Cancelled Projects")
               (org-agenda-files org-agenda-files)))))))

#+end_src

To add a tag to a task, use ~counsel-org-tag~

Add some predefine tags
#+begin_src emacs-lisp
  (setq org-tag-alist
    '((:startgroup)
       ; Put mutually exclusive tags here
       (:endgroup)
       ("@errand" . ?E)
       ("@home" . ?H)
       ("@work" . ?W)
       ("agenda" . ?a)
       ("planning" . ?p)
       ("publish" . ?P)
       ("batch" . ?b)
       ("note" . ?n)
       ("idea" . ?i)))

#+end_src

Refill is the ability to move some text to other file when some action
happen or event is trigger.  On the following section, we go to setup
some triggers for the agenda mode. This allows as to archive the task
that are done

#+begin_src emacs-lisp
  (setq org-refile-targets
    '(("Archive.org" :maxlevel . 1)
      ("Tasks.org" :maxlevel . 1)))

  ; Save Org buffers after refiling!
  (advice-add 'org-refile :after 'org-save-all-org-buffers)
#+end_src
*** Capture template

#+begin_src emacs-lisp

  (setq org-capture-templates
      `(("t" "Tasks / Projects")
        ("tt" "Task" entry (file+olp "~/Documents/Org_EFS/Tasks.org" "Inbox")
             "* TODO %?\n  %U\n  %a\n  %i" :empty-lines 1)

        ("j" "Journal Entries")
        ("jj" "Journal" entry
             (file+olp+datetree "~/Documents/Org_EFS/Journal.org")
             "\n* %<%I:%M %p> - Journal :journal:\n\n%?\n\n"
             ;; ,(dw/read-file-as-string "~/Notes/Templates/Daily.org")
             :clock-in :clock-resume
             :empty-lines 1)
        ("jm" "Meeting" entry
             (file+olp+datetree "~/Documents/Org_EFS/Journal.org")
             "* %<%I:%M %p> - %a :meetings:\n\n%?\n\n"
             :clock-in :clock-resume
             :empty-lines 1)

        ("w" "Workflows")
        ("we" "Checking Email" entry (file+olp+datetree "~/Documents/Org_EFS/Journal.org")
             "* Checking Email :email:\n\n%?" :clock-in :clock-resume :empty-lines 1)

        ("m" "Metrics Capture")
        ("mw" "Weight" table-line (file+headline "~/Documents/Org_EFS/Metrics.org" "Weight")
         "| %U | %^{Weight} | %^{Notes} |" :kill-buffer t)))

#+end_src

Also, we can define some binding to open captures

#+begin_src emacs-lisp
  (define-key global-map (kbd "C-c j")
    (lambda () (interactive) (org-capture nil "jj")))
#+end_src

But is preffer to assing a keybinding to org-capure

#+begin_src emacs-lisp
(global-set-key (kbd "C-c c") 'org-capture)
#+end_src

**** Org habit
#+begin_src emacs-lisp
 (require 'org-habit)
  (add-to-list 'org-modules 'org-habit)
  (setq org-habit-graph-column 60)
#+end_src

The habits are task with a repeat periods. You can see the task into the agenda-dashboard and
remember you to do and what times you skip it.

*** Org links

#+begin_src emacs-lisp
;; An example of how this works.
;; [[arch-wiki:Name_of_Page][Description]]
(setq org-link-abbrev-alist    ; This overwrites the default Doom org-link-abbrev-list
        '(("google" . "http://www.google.com/search?q=")
          ("arch-wiki" . "https://wiki.archlinux.org/index.php/")
          ("ddg" . "https://duckduckgo.com/?q=")
          ("wiki" . "https://en.wikipedia.org/wiki/")))
#+end_src


*** Configure Babel languages

To execute or export code in org-mode code blocks, you’ll need to set up org-babel-load-languages
for each language you’d like to use. [[https:orgmode.org/worg/org-contrib/babel/languages/index.html][This page]] documents all of the languages that you can use with
org-babel.

#+begin_src emacs-lisp
(org-babel-do-load-languages
  'org-babel-load-languages
  '((emacs-lisp . t)
    (python . t)))

(push '("conf-unix" . conf-unix) org-src-lang-modes)
#+end_src

** Org toc
#+begin_src emacs-lisp
(use-package toc-org
  :commands toc-org-enable
  :init (add-hook 'org-mode-hook 'toc-org-enable))
#+end_src

** Org export manpage
#+begin_src emacs-lisp
(use-package ox-man
  :ensure nil)
#+end_src

*** Org export to markdown
#+begin_src emacs-lisp
(use-package ox-gfm)
#+end_src

*** Structure templates

Org Mode's [[https://orgmode.org/manual/Structure-Templates.html][structure templates]] feature enables you to quickly insert code blocks into your Org files in combination with =org-tempo= by typing =<= followed by the template name like =el= or =py= and then press =TAB=.  For example, to insert an empty =emacs-lisp= block below, you can type =<el= and press =TAB= to expand into such a block.

You can add more =src= block templates below by copying one of the lines and changing the two strings at the end, the first to be the template name and the second to contain the name of the language [[https://orgmode.org/worg/org-contrib/babel/languages.html][as it is known by Org Babel]].

#+begin_src emacs-lisp

  ;; This is needed as of Org 9.2
  (require 'org-tempo)

  (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
  (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("py" . "src python"))

#+end_src

** Org Roam
Org-roam is a tool for networked thought. It reproduces some of the Roam Research's key features
within Org-mode

*** Instalation
The instalation process use the melpa or melpa stable package manager from emacs. 

#+begin_src 
(use-package org-roam)
#+end_src

Some dependencies are:
- dash
- f
- s
- org
- emacsql
- emacsql-sqlite
- magit-section

  
*** Setting up Org-roam

Org-roam’s capabilities stem from its aggressive caching: it crawls all files within
org-roam-directory, and maintains a cache of all links and nodes.

#+begin_src emacs-lisp
(setq org-roam-directory "~/Documents/Org-roam")
#+end_src

Autosync mode allows to keep track and cache all changes to maintain cache consistency

#+begin_src emacs-lisp
(org-roam-db-autosync-mode)
#+end_src

If you're using a vertical completion framework, such as Ivy, Org-roam supports the generation of an
aligned, tabular completion interface. For example, to include a column for tags, one can set
org-roam-node-display-template as such:

#+begin_src emacs-lisp
(setq org-roam-node-display-template
      (concat "${title:*} "
              (propertize "${tags:10}" 'face 'org-tag)))
#+end_src

*** What to cache

One can exclude some nodes, for example, to exclude all the headlines with the ATTACH tag

#+begin_src emacs-lisp
(setq org-roam-db-node-include-function
      (lambda ()
        (not (member "ATTACH" (org-get-tags)))))
#+end_src

* Development
** Languages

*** IDE Features with lsp-mode

**** lsp-mode

We use the excellent [[https://emacs-lsp.github.io/lsp-mode/][lsp-mode]] to enable IDE-like functionality for many different programming languages via "language servers" that speak the [[https://microsoft.github.io/language-server-protocol/][Language Server Protocol]].  Before trying to set up =lsp-mode= for a particular language, check out the [[https://emacs-lsp.github.io/lsp-mode/page/languages/][documentation for your language]] so that you can learn which language servers are available and how to install them.

The =lsp-keymap-prefix= setting enables you to define a prefix for where =lsp-mode='s default keybindings will be added.  I *highly recommend* using the prefix to find out what you can do with =lsp-mode= in a buffer.

The =which-key= integration adds helpful descriptions of the various keys so you should be able to learn a lot just by pressing =C-c l= in a =lsp-mode= buffer and trying different things that you find there.

#+begin_src emacs-lisp

  (defun efs/lsp-mode-setup ()
    (setq lsp-headerline-breadcrumb-segments '(path-up-to-project file symbols))
    (lsp-headerline-breadcrumb-mode))

  (use-package lsp-mode
    :commands (lsp lsp-deferred)
    :hook (lsp-mode . efs/lsp-mode-setup)
    :init
    (setq lsp-keymap-prefix "C-c l")  ;; Or 'C-l', 's-l'
    :config
    (lsp-enable-which-key-integration t))

#+end_src

**** lsp-ui

[[https://emacs-lsp.github.io/lsp-ui/][lsp-ui]] is a set of UI enhancements built on top of =lsp-mode= which make Emacs feel even more like an IDE.  Check out the screenshots on the =lsp-ui= homepage (linked at the beginning of this paragraph) to see examples of what it can do.

#+begin_src emacs-lisp

  (use-package lsp-ui
    :hook (lsp-mode . lsp-ui-mode)
    :custom
    (lsp-ui-doc-position 'bottom))

#+end_src

**** lsp-treemacs

[[https://github.com/emacs-lsp/lsp-treemacs][lsp-treemacs]] provides nice tree views for different aspects of your code like symbols in a file, references of a symbol, or diagnostic messages (errors and warnings) that are found in your code.

Try these commands with =M-x=:

- =lsp-treemacs-symbols= - Show a tree view of the symbols in the current file
- =lsp-treemacs-references= - Show a tree view for the references of the symbol under the cursor
- =lsp-treemacs-error-list= - Show a tree view for the diagnostic messages in the project

This package is built on the [[https://github.com/Alexander-Miller/treemacs][treemacs]] package which might be of some interest to you if you like to have a file browser at the left side of your screen in your editor.

#+begin_src emacs-lisp

  (use-package lsp-treemacs
    :after lsp)

#+end_src

**** lsp-ivy

[[https://github.com/emacs-lsp/lsp-ivy][lsp-ivy]] integrates Ivy with =lsp-mode= to make it easy to search for things by name in your code.  When you run these commands, a prompt will appear in the minibuffer allowing you to type part of the name of a symbol in your code.  Results will be populated in the minibuffer so that you can find what you're looking for and jump to that location in the code upon selecting the result.

Try these commands with =M-x=:

- =lsp-ivy-workspace-symbol= - Search for a symbol name in the current project workspace
- =lsp-ivy-global-workspace-symbol= - Search for a symbol name in all active project workspaces

#+begin_src emacs-lisp

  (use-package lsp-ivy)

#+end_src


*** TypeScript

This is a basic configuration for the TypeScript language so that =.ts= files activate =typescript-mode= when opened.  We're also adding a hook to =typescript-mode-hook= to call =lsp-deferred= so that we activate =lsp-mode= to get LSP features every time we edit TypeScript code.

#+begin_src emacs-lisp

  (use-package typescript-mode
    :mode "\\.ts\\'"
    :hook (typescript-mode . lsp-deferred)
    :config
    (setq typescript-indent-level 4))

#+end_src

*Important note!*  For =lsp-mode= to work with TypeScript (and JavaScript) you will need to install a language server on your machine.  If you have Node.js installed, the easiest way to do that is by running the following command:

#+begin_src shell :tangle no

npm install -g typescript-language-server typescript

#+end_src

This will install the [[https://github.com/theia-ide/typescript-language-server][typescript-language-server]] and the TypeScript compiler package.

** Company Mode

[[http://company-mode.github.io/][Company Mode]] provides a nicer in-buffer completion interface than =completion-at-point= which is
more reminiscent of what you would expect from an IDE.  We add a simple configuration to make the
keybindings a little more useful (=TAB= now completes the selection and initiates completion at the
current location if needed).

We also use [[https://github.com/sebastiencs/company-box][company-box]] to further enhance the look of the completions with icons and better overall presentation.

#+begin_src emacs-lisp

  (use-package company
    :after lsp-mode
    :hook (lsp-mode . company-mode)
    :bind (:map company-active-map
           ("<tab>" . company-complete-selection))
          (:map lsp-mode-map
           ("<tab>" . company-indent-or-complete-common))
    :custom
    (company-minimum-prefix-length 1)
    (company-idle-delay 0.0))

  (use-package company-box
    :hook (company-mode . company-box-mode))

#+end_src

** Projectile

Projectile is a package aims to allows you manage your projets. In the
next cell you are install the package, change the completion system,
setting the folder where most of your projects are stored

#+begin_src emacs-lisp
  (use-package projectile
    :diminish projectile-mode
    :config (projectile-mode)
    :custom ((projectile-completion-system 'ivy))
    :bind-keymap
    ("C-c p" . projectile-command-map))
    (setq projectile-switch-project-action #'projectile-dired)

  (use-package counsel-projectile
    :config (counsel-projectile-mode))

#+end_src

Something very interesant from projectile is that, it allows you to
setup some variables from specific projects when a buffer of this
project is loaded. To do it you need should press "C-c p e" 

Also you can make a recursive search in the project with different
search engienieere with ~counsel-projectile-rg~ <-> ~C-c p e r~

** Magit
[[https://github.com/magit/magit][magit github]]

#+begin_src emacs-lisp
(use-package magit
  :custom
  (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))

#+end_src

*** Operations

Run ~magit-status~ in buffer from Git repo, press ~?~ for command pannel

Refresh buffer with ~g r~

 - Diffs
 - Commit log
 - Blame
 - Stashes
 - Branches
 - Rebase
 - Pull/push

To activate the git command, just press ~g~

You can add changes to a previous push, stashing the changes, go to the commit
and apply there

*** Forge

Forge allows you to interact with github inside emacs

#+begin_src emacs-lisp
    (use-package forge
      :after magit)
#+end_src

** Copilot
To enable copilot, first I need to isntall straight, an emacs package
that allows you to run code from at the download moment

*** Straight

Straight is a package aims to allow download any kind of repo from trusted and unstrasted sources
and run some code while the instlation

#+begin_src emacs-lisp
      (defvar bootstrap-version)
      (let ((bootstrap-file
             (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
            (bootstrap-version 6))
        (unless (file-exists-p bootstrap-file)
          (with-current-buffer
              (url-retrieve-synchronously
               "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
               'silent 'inhibit-cookies)
            (goto-char (point-max))
            (eval-print-last-sexp)))
        (load bootstrap-file nil 'nomessage))

#+end_src

Now, I can install copilo

*** Install copilot

Emacs does not have an official copilot repo, so there are some alternatives. [[https:zerlfx/copilot.el][This repo]] clone the
functionlities from the vim copilot script from github.

#+begin_src emacs-lisp

  (use-package copilot
    :straight (:host github :repo "zerolfx/copilot.el" :files ("dist" "copilot.el")) :ensure t)

  (add-hook 'prog-mode-hook 'copilot-mode)

#+end_src

*** Uso copilot with company

#+begin_src emacs-lisp
(with-eval-after-load 'company
  ;; disable inline previews
  (delq 'company-preview-if-just-one-frontend company-frontends))
  
(define-key copilot-completion-map (kbd "<tab>") 'copilot-accept-completion)
(define-key copilot-completion-map (kbd "TAB") 'copilot-accept-completion)

#+end_src

** Rainbow-delimeters
#+begin_src emacs-lisp
(use-package rainbow-delimiters
:hook (prog-mode . rainbow-delimiters-mode))
#+end_src
** Key binding

To create a keybinding there are a lot of ways to do that. One is just used allowing escape quit with the <scape> key. Also the package general, allows you to set up in more verbose way the keybinding

#+begin_src example
  (use-package general)
  (general-define-key
     "C-M-j" 'counsel-switch-buffer)
#+end_src

With general-create-definer, the package create a function to setup a prefix for your keybinding. 



* Writting
** Configure flyspell
Fly spell is a mode that allows you to see typing errors. By default it is disable, but can be
configure to be used on different kinds of situations.

#+begin_src emacs-lisp
(use-package flyspell
    :config
    (setq ispell-program-name "hunspell"
          ispell-default-dictionary "en_US")
    :hook (text-mode . flyspell-mode)
    :bind (("M-<f7>" . flyspell-buffer)
           ("<f7>" . flyspell-word)
           ("C-;" . flyspell-auto-correct-previous-word)))
#+end_src
